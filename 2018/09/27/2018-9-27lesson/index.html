<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>2018-9-27lesson | aKer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="最近是面试期么内心一定要淡定记录下最近面试问到的一些问题之前从粉粉离开时，也没想到这是一个多事之秋。去了一家动漫IP 的公司，人没去之前老板已经有意决定停下互联网业务的，结果其中一个合伙人说再试一波，于是我以为其是想做事，就进去当小白鼠了。进去之后改版页面完，没目的没计划了。做了一个egret ”消消乐“的微信小游戏，学了该学的OpenGLES，然后中秋之前跟我说部门解散，，， 大哥，这才三个月啊">
<meta property="og:type" content="article">
<meta property="og:title" content="2018-9-27lesson">
<meta property="og:url" content="https://akerdi.github.io/2018/09/27/2018-9-27lesson/index.html">
<meta property="og:site_name" content="aKer">
<meta property="og:description" content="最近是面试期么内心一定要淡定记录下最近面试问到的一些问题之前从粉粉离开时，也没想到这是一个多事之秋。去了一家动漫IP 的公司，人没去之前老板已经有意决定停下互联网业务的，结果其中一个合伙人说再试一波，于是我以为其是想做事，就进去当小白鼠了。进去之后改版页面完，没目的没计划了。做了一个egret ”消消乐“的微信小游戏，学了该学的OpenGLES，然后中秋之前跟我说部门解散，，， 大哥，这才三个月啊">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2023-03-07T09:24:38.371Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="2018-9-27lesson">
<meta name="twitter:description" content="最近是面试期么内心一定要淡定记录下最近面试问到的一些问题之前从粉粉离开时，也没想到这是一个多事之秋。去了一家动漫IP 的公司，人没去之前老板已经有意决定停下互联网业务的，结果其中一个合伙人说再试一波，于是我以为其是想做事，就进去当小白鼠了。进去之后改版页面完，没目的没计划了。做了一个egret ”消消乐“的微信小游戏，学了该学的OpenGLES，然后中秋之前跟我说部门解散，，， 大哥，这才三个月啊">
  
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
  <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      document.querySelectorAll('pre code').forEach((block) => {
        hljs.highlightBlock(block);
      });
    });
  </script>
  <link rel="stylesheet" href="/css/index.css">
</head>
</html>
<body style="


  background-color: #eff0f6

">
  <div id="container">
    <nav id="nav">
  <header class="header">
    <a href="/" class="title">Clover Tuan</a>
  </header>
  <div class="ctnWrap">
    <div class="icons">
      
        
          
            <a href="https://dribbble.com/clovertuan" target="_blank" class="nav-icn iconfont icon-dribbble"></a>
          
        
          
            <a href="https://www.behance.net/clovertuan" target="_blank" class="nav-icn iconfont icon-behance"></a>
          
        
          
            <a href="http://clovertuan.lofter.com/" target="_blank" class="nav-icn iconfont icon-lofter"></a>
          
        
          
            <a href="https://www.instagram.com/clovertuan/" target="_blank" class="nav-icn iconfont icon-instagram"></a>
          
        
          
            <a href="https://github.com/cloverTuan" target="_blank" class="nav-icn iconfont icon-github"></a>
          
        
      
    </div>
    <div class="menu">
      
        
            <a href="/" class="nav-menu ">HOME</a>
          
        
            <a href="/archives" class="nav-menu ">ARCHIVE</a>
          
        
            <a href="/about" class="nav-menu ">ABOUT</a>
          
        
      
    </div>
  </div>
</nav>
    <div id="main"><section class="article">
  <h2 class="title">2018-9-27lesson</h2>
  <p class="sub">Sep 27, 2018</p>
  <article class="content">
    <h1 id="最近是面试期么"><a href="#最近是面试期么" class="headerlink" title="最近是面试期么"></a>最近是面试期么</h1><h2 id="内心一定要淡定"><a href="#内心一定要淡定" class="headerlink" title="内心一定要淡定"></a>内心一定要淡定</h2><h3 id="记录下最近面试问到的一些问题"><a href="#记录下最近面试问到的一些问题" class="headerlink" title="记录下最近面试问到的一些问题"></a>记录下最近面试问到的一些问题</h3><p>之前从粉粉离开时，也没想到这是一个多事之秋。去了一家动漫IP 的公司，人没去之前老板已经有意决定停下互联网业务的，结果其中一个合伙人说再试一波，于是我以为其是想做事，就进去当小白鼠了。进去之后改版页面完，没目的没计划了。做了一个egret ”消消乐“的微信小游戏，学了该学的OpenGLES，然后中秋之前跟我说部门解散，，，</p>
<p>大哥，这才三个月啊。</p>
<p>所以说是一个多事之秋吧。</p>
<p>好吧，出来面试吧。</p>
<p>现在是9月份，面试第一个公司：”第一弹“，我个人觉得面试过程还好，然后说不合适。好吧，不合适就不合适吧，可惜了，距离我挺近的，比较看重距离。</p>
<p>面试题里面有个题目：[1, … 100] 内 不等随机大小无序数，求最大的数和第二大的数。</p>
<p>这个我做的时候直接是冒泡排序。但是有两层for 循环，效率不好，下面会给出最佳答案。</p>
<p>第二家说想做一个短视频、即时通讯、webRTC 这一类产品。我不看好，不能跟，而且离得有点远，开发员工才几个人，工资也很低。大哥，做这类的工资不可能才15k 啊，，，做成个半成品，全是SDK 的，我不愿意把青春花在简单组合各类SDK上面，做完到时发现不赚钱，老板说解散，到时我又屁颠屁颠要出来找工作，何必。后来，之前面试的小哥打电话过来问意愿，那边那个老板也打电话过来问意愿，只能拒绝。没有投靠的意义，看的出来老板只是想试试水。</p>
<p>第三家在之前我就有去面试的地方：徐汇慧谷创业中心。这家是做 AI提供用户数据给出用户穿衣服方案的公司。在找iOS 开发。先来个小胖哥，上来就说我看了你的博客了，还挺好，直接让技术经理来考你。这小胖哥有意思，人好。然后技术大哥来了就问技术的事，不与iOS 相关的，先问TCP协议（我没看面试题之类的（最近在搞网页）答得不好），然后出了两个题目：</p>
<ol>
<li>数组array[1~n] 随机大小无序，求从大到小第k个数。解法：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nums[n] = [<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (int i=<span class="number">0</span>;i&lt;array.count;i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> element = array[i];</span><br><span class="line">    <span class="keyword">if</span> (nums[element]) &#123;<span class="comment">//如果有值</span></span><br><span class="line">        nums[element] = nums[element] ++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nums[element] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个时候从n 到 1 如果内部是&gt;1 的都是有值的，&gt;2那就是有两个值. 于是第k 个值也能得出。</span></span><br></pre></td></tr></table></figure>
<p>这正是“第一弹”笔试的比较好的答案吧。</p>
<ol start="2">
<li>有一个圆盘时钟，从00:00:00 ~ 24:00:00 过程有多少次秒针、分针、时针是全部重叠的。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="number">360</span>°/<span class="number">60</span> * n; <span class="comment">//秒针一圈第n秒时在什么角度</span></span><br><span class="line"><span class="keyword">let</span> m = <span class="number">360</span>°/(<span class="number">60</span>*<span class="number">60</span>) * n; <span class="comment">//分针一圈第n秒时在什么角度</span></span><br><span class="line"><span class="keyword">let</span> h = <span class="number">360</span>°/(<span class="number">12</span>*<span class="number">60</span>*<span class="number">60</span>) * n; <span class="comment">//时针一圈第n秒时在什么角度</span></span><br><span class="line"><span class="keyword">for</span> (int n=<span class="number">0</span>; n&lt;<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>; n++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s / <span class="number">360</span>° == m / <span class="number">360</span>° == h / <span class="number">360</span>°) &#123;<span class="comment">//除以360° 是让其点化为单位角度</span></span><br><span class="line">        <span class="comment">// 这就是相遇的点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个挺考智商的。但是我的脑子不好，我的学习都是不断的抄写他人知识，融合这些知识，所以直接回答纯粹的算法题我答的不好。比如第1题我还是使用冒泡排序，嘿嘿。当时甚至于冒泡排序还写错了。比较紧张吧：因为先回答了圆盘时钟的问题，却一直没解出来，导致思绪乱了，后面答第一个问题也更乱了。</p>
<p>下面是借口，借口：</p>
<p>一直学习，没顾上看面试题，没顾上看看算法题。面试完确实对我心里有点打击：我就是做个iOS，现在还需要算法了？iOS没有算法啊，苹果都给你优化过了，你写再好，比得过人家一个api？但是话说来，算法才是程序的灵魂，没有灵魂，写再多api 也不是程序。</p>
<p>我的观点是，面试的时候遇到了什么不清晰的地方，就好好记录下来。平常学必要的，不要全都学，现在那么多知识点，哪里学的完。这没什么好狡辩，尽力无悔即可。</p>
<p>唉，换工作比较麻烦，我早自知。但是我相信，现在困惑、困难，“树挪死，人挪活”，艰难刻苦总会过去的吧（目前还在艰难困苦中）。学到、实践到就是没白费过。</p>
<h4 id="今天2018-9-26-两个面试。"><a href="#今天2018-9-26-两个面试。" class="headerlink" title="今天2018.9.26 两个面试。"></a>今天2018.9.26 两个面试。</h4><p>上午的面试面着面着，快一小时了，才知道他们要招员工到张江去上班的，唉，我看你是10k~15k过来试着面试面试，没想到你比我还皮，这个比较浪费时间，，算了心平气和滚蛋了，嘎嘎。</p>
<p>下午离得稍微有点远，叫”Ratta” 雷塔的一个公司。我觉得功能方向稍微有点不太合适，也是试试去面试吧。</p>
<p>先笔试：考跟之前算法一样的东西（现在全部公司的笔试题都一样了？）。答题吧。</p>
<p>里面还有一个是跟我的APP“哈皮涂色”很类似的同步数据、展示数据的题目。<br>面试的是写c、c++ 的大哥。这人对基本数据比较了解。说一个数据{x:x,y:y,color:color} 这样一个int 数据元素要占用多少位？我肯定不知道啊，我就说bytes 是4字节，多少位我不知道。他说32位（int 是32位，NSInteger 是64，问这个干嘛哟，这个是读取速度，不是储存大小，我感觉这个大哥不是很靠谱，个人感觉）。然后他想问的如何压缩可以将数据不会存储那么大。我一时间哪能那么快想出来啊，能想出来答出来，那我肯定之前做过了，碰到过了，不然我答什么呀。</p>
<p>之后就是问随意的问题。</p>
<p>其中给他看了我的“哈皮涂色”，估计他有点懵逼了：这是他们公司的主营功能。他们有个硬件进行绘画，我直接就是手机上直接画。他们有点想知道核心功能，我才不告诉他们嘞，要知道？得花钱。</p>
<p>然后问了一些技术上的问题，他也做了些功课：</p>
<ol>
<li>堆和栈的区别(还别说，没看面试题，我也都快忘光了，随便解答) 。</li>
</ol>
<blockquote>
<p>一个由c/C++编译的程序占用的内存分为以下几个部分：</p>
<ul>
<li>栈区（stack）— 由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</li>
<li>堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</li>
<li>全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。</li>
<li>文字常量区 —常量字符串就是放在这里的。程序结束后由系统释放。</li>
<li>程序代码区—存放函数体的二进制代码。</li>
</ul>
</blockquote>
<ol start="2">
<li>反射机制（从没用过~查询得知，其实就是使用字符动态查找创建类、方法，方便网络和客户端交互。反正我没这么用，多不安全啊。）</li>
<li>https（我说上家公司没处理过，不过之前公司处理过，iOS 这里只需在网络那里配置下就好了，如果要双向验证，那就在iOS本地增加配置一个公钥，额，他还不信，害我跑回来看教程，没错啊，客户端要处理的真的很少。服务端也不多，nodejs 之前的我看过相关的教程，就增加配置个证书文件嘛）</li>
</ol>
<p><a href="https://www.jianshu.com/p/6b561705de06" target="_blank" rel="noopener">参考网址</a></p>
<p>单向验证</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//在你封装的网络工具类请求前初始化时增加以下代码</span><br><span class="line">AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</span><br><span class="line">//设置证书模式，AFSSLPinningModeNone，代表前端包内不验证</span><br><span class="line">//在单向认证时，前端不放证书，服务器去验证</span><br><span class="line">AFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeNone];</span><br><span class="line">// 如果是需要服务端验证证书，需要设置为YES</span><br><span class="line">securityPolicy.allowInvalidCertificates = YES;</span><br><span class="line">//validatesDomainName 是否需要验证域名，默认为YES；</span><br><span class="line">securityPolicy.validatesDomainName = NO;</span><br><span class="line">//设置验证模式</span><br><span class="line">manager.securityPolicy = securityPolicy;</span><br></pre></td></tr></table></figure>
<p>双向验证</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//在你封装的网络工具类请求前初始化时增加以下代</span><br><span class="line">AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</span><br><span class="line">//设置验证证书，该模式下许愿把证书打包进项目里，进行验证</span><br><span class="line">AFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];</span><br><span class="line">//证书的路径</span><br><span class="line">NSString *cerPath = [[NSBundle mainBundle] pathForResource:@&quot;xxx&quot; ofType:@&quot;.cer&quot;];</span><br><span class="line">NSData *dataSou = [NSData dataWithContentsOfFile:cerPath];</span><br><span class="line">NSSet *set = [NSSet setWithObjects:dataSou, nil];</span><br><span class="line">securityPolicy.allowInvalidCertificates = YES;</span><br><span class="line">securityPolicy.validatesDomainName = YES;</span><br><span class="line">[securityPolicy setPinnedCertificates:set];</span><br><span class="line">//将验证方式赋值给管理者</span><br><span class="line">manager.securityPolicy = securityPolicy;</span><br></pre></td></tr></table></figure>
<p>HTTPS 处理过程是在“[应用层] - <strong>[SSL/TLS]</strong> - [TCP] - [IP]”之间。HTTP 的TCP 握手是三次，但是HTTPS 握手需要更多次，因为这里使用非对称加密、对称加密等加密手段对数据进行保护。</p>
<p>首先先理解加解密数据性能，非对称加密RSA 性能需要CPU 计算，寻找素数，耗时相对大，优点就是公钥可以公布，但是如果仅做一次，互相之间传递secretKey 就是非常好的；对称加密AES 速度快，但是需要互相之间都保存有secretKey。</p>
<p>HTTPS 使用到的加密算法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">非对称加密算法：RSA，DSA/DSS </span><br><span class="line">对称加密算法：AES，RC4，3DES </span><br><span class="line">HASH算法：MD5，SHA1，SHA256</span><br></pre></td></tr></table></figure>
<p>最简单的理解或者说模拟出一个HTTPS 一次传输过程要处理的事（只讲算法之间要干的事，更多请阅读下面参考链接讲解的过程）：</p>
<ul>
<li><p>客户端一开始和服务端使用公钥加密这次要使用的secretKey。因为大家都没有私钥，所以也不怕被截取。</p>
</li>
<li><p>服务器保存此次对应的人和对应的secretKey，同时可以使用AES 对从客户端收到了secretKey 的回应，加密的密钥就是secretKey。</p>
</li>
</ul>
<p>服务端使用RSA 使用secretKey 私钥加密数据给客户端。</p>
<p>客户端使用该secretKey 来给数据进行AES 加密。</p>
<p>这样就完成加解密的过程了。</p>
<p>上面的过程比较简单化，HTTPS 还做了很多，不过我只理解简单的，然后把他写下来。</p>
<p>可以参考<a href="http://www.cnblogs.com/Yfling/p/6670495.html" target="_blank" rel="noopener">HTTPS加密原理</a></p>
<h3 id="继续看面试题"><a href="#继续看面试题" class="headerlink" title="继续看面试题"></a>继续看面试题</h3><p>1:SEL Method</p>
<p>SEL 方法编号：<br>SEL methodId = @selector(func1);<br>执行SEL:<br>[self performSelector:methodId withObject:nil];<br>IMP 获得和使用:<br>IMP methodPoint = [self methodForSelctor:methodId];<br>调用：methodPoint();<br>IMP objectMethodPoint = [object methodFor:@selector(message)]<br>调用：theResult = objectMethodPoint(anObject, aSelector);</p>
<p>2:<br>反射机制<br>系统Foundation 下有这几个反射API</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_EXPORT NSString *NSSTringFromSelector(SEL aSelector);</span><br><span class="line">FOUNDATION_EXPORT SEL NSSelectorFromString(NSString *aSelectorName);</span><br><span class="line">FOUNDATION_EXPORT NSString *NSStringFromClass(Class aClass);</span><br><span class="line">FOUNDATION_EXPORT Class __nullable NSClassFromString(NSString *aClassName);</span><br><span class="line">FOUNDATION_EXPORT NSString *NSStringFromProtocol(Protocol *proto) NS_AVAILABLE(10_5, 2_0);</span><br><span class="line">FOUNDATION_EXPORT Protocol * __nullable NSProtocolFromString(NSString *namestr) NSAVAIABLE(10_5, 2_0);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isKindOfClass:(Class)aClass;</span><br><span class="line">- (BOOL)isMemberOfClass:(Class)aClass;</span><br><span class="line">- (BOOL)conformsToProtocol:(Protocol *)aProtocol;</span><br><span class="line">- (BOOL)respondsToSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure>
<p>3:NSDictionary</p>
<p>iOS 的NSDictionary 是使用hash表来实现key value 的键值映射和存储的。于Typescript 一样，键都是转为string 类型查找。<br>根据这篇文章<a href="https://www.jianshu.com/p/915356e280fc" target="_blank" rel="noopener">参考</a> 能更深入了解NSDictionary 实现思路。</p>
<p>首先NSArray 是没有hash 表来映射快速查找方法。时间复杂度就是o(n),数据长度。NSDictionary 在setObject 时提前判别对象hash 值是否已经存在。判别分两步：Step1：== 运算符判别对象指针是否相等；Step2:判别是否是同一类型；Step3:判别内在属性是否相等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isEqual:(id)object &#123;</span><br><span class="line">    if (self == object) &#123;</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    if (![object isKinkOfClass:[Person class]]) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return [self isEqualToPerson:(Person *)object];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isEqualToPerson:(Person *)person &#123;</span><br><span class="line">    if (!person) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BOOL haveEqualNames = (!self.name &amp;&amp; !person.name) || (self.name isEqualToString:person.name);</span><br><span class="line">    BOOL haveEqualbirthday = (!self.birthday &amp;&amp; !person.birthday) || (self.birthday isEqualToDate:person.birthday);</span><br><span class="line"></span><br><span class="line">    return haveEqualNames &amp;&amp; haveEqualBirthdays;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上部分可以采用RunTime 寻找属性判别。</p>
<p>Hash Table 查找成员过程：Step1：通过hash值直接找到目标位置；Step2：如果目标位置上有多个相同hash值成员，再按照数组方式查找。</p>
<p>Hash 调用时间：对象被添加至NSSet、设置NSDictionary 的key 时调用。</p>
<p>正确重置Person 的hash 方式实现：</p>
<p>大神Mattt Thompson在Equality中给出的结论就是</p>
<blockquote>
<p>In reality, a simple XOR over the hash values of critical properties is sufficient 99% of the time(对关键属性的hash值进行位或运算作为hash值)</p>
</blockquote>
<p>正确返回重置hash</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInter)hash &#123;</span><br><span class="line">    return [self.name hash] ^ [self.birthday hash];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4:Block</p>
<p>Block本质就是对象，因为本身就有指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, const char * argv) &#123;</span><br><span class="line">    void (^block)() = ^&#123;</span><br><span class="line">        printf(&apos;hello world&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    block();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用clang 指令<br><code>clang -rewrite-objc main.m</code> 得到一个cpp 文件。<br>定义完block，创建了一个函数，在创建结构体时，同时把函数指针也传进去了。之后就可以拿出来使用了。</p>
<p>5：线程间通讯<a href="https://www.jianshu.com/p/f9f3952a4a74" target="_blank" rel="noopener">参考网址</a></p>
<p>1) NSThread</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)thread &#123;</span><br><span class="line">    NSString *imageUrlString;</span><br><span class="line">    [self performSelectorInBackground:@selector(loadImage:) withObject:imageUrlString];</span><br><span class="line">&#125;</span><br><span class="line">- (void)loadImage:(NSString *)imageUrlString &#123;</span><br><span class="line">    NSData *imageData = [NSData dataWithContentURL:[NSUrl urlWithString:imageUrlString]];</span><br><span class="line">    [self performSelectorOnMainThread:@selector(updateUI:) withObject:imageData];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2) GCD</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)gcd &#123;</span><br><span class="line">    NSString *imageUrlString;</span><br><span class="line">    __Weak typeof(self) weakSelf = self;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">        NSData *imageData = [NSData dataWithContentURL:[NSUrl urlWithString:imageUrlString]];</span><br><span class="line">        dispatch_async(dispatch_get_main_queue, ^&#123;</span><br><span class="line">            weakSelf.imageView.image = [UIImage imageWithData:imageData];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3) NSOperation</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (void)operation &#123;</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    DownLoadOperation *downLoadOp = [DownLoadOperation new];</span><br><span class="line">    downLoadOp.imageUrlString = xxx;</span><br><span class="line">    downLoadOp.finishedBlock = ^(UIImage *image) &#123;</span><br><span class="line">        [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">            weakSelf.imageView.image = image;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;;</span><br><span class="line">    NSOperationQueue *concurrentQueue = [NSOperationQueue new];</span><br><span class="line">    [concurrentQueue addOperation:downLoadOp];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@interface DownloadOperation : NSOperation</span><br><span class="line">@property (nonatomic, copy) NSString *imageUrlString;</span><br><span class="line">@property (nonatomic, copy) FinishedBlock finishedBlock;</span><br><span class="line">@end</span><br><span class="line">@implementation DownloadOperation</span><br><span class="line">- (void)main &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSData *imageData = [NSData dataWithContentURL:[NSUrl urlWithString:self.imageUrlString]];</span><br><span class="line">        if (self.finishedBlock)</span><br><span class="line">            self.finishedBlock([UIImage imageWithData:imageData]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>4) 加密算法</p>
<p><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434501504929883d11d84a1541c6907eefd792c0da51000" target="_blank" rel="noopener">廖雪峰-node-crypto</a></p>
<p>MD5和SHA1</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"><span class="keyword">const</span> hash = crypto.createHash(<span class="string">'md5'</span>);<span class="comment">//crypto.createHash('sha1');/sha256/sha512</span></span><br><span class="line">hash.update(<span class="string">'Hello, world'</span>);</span><br><span class="line">hash.update(<span class="string">'hello, nodejs'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(hash.digest(<span class="string">'hex'</span>));</span><br></pre></td></tr></table></figure>
<p>Hmac 可以把Hmac理解为用随机数“增强”的哈希算法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"><span class="keyword">const</span> hmac = crypto.createHmac(<span class="string">'sha256'</span>, <span class="string">'your secret-key'</span>);</span><br><span class="line">hmac.update(<span class="string">'Hello, world'</span>);</span><br><span class="line">hmac.update(<span class="string">'Hello, nodejs'</span>);</span><br><span class="line">hmac.digest(<span class="string">'hex'</span>);</span><br></pre></td></tr></table></figure>
<p>AES 对称加密算法，加解密都用同一个密钥</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aesEncrypt</span>(<span class="params">data, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> cipher = crypto.createCipher(<span class="string">'aes192'</span>, key);</span><br><span class="line">    <span class="keyword">let</span> crypted = cipher.update(data, <span class="string">'utf8'</span>, <span class="string">'hex'</span>);</span><br><span class="line">    crypted += cipher.final(<span class="string">'hex'</span>);</span><br><span class="line">    <span class="keyword">return</span> crypted;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aesDecrypt</span>(<span class="params">encrypted, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> decipher = crypto.createDecipher(<span class="string">'aes192'</span>, key);</span><br><span class="line">    <span class="keyword">let</span> decrypted = decipher.update(encrypted, <span class="string">'hex'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">    decrypted += decipher.final(<span class="string">'utf8'</span>);</span><br><span class="line">    <span class="keyword">return</span> decrypted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = <span class="string">'Hello, this is a secret message!'</span>;</span><br><span class="line"><span class="keyword">let</span> key = <span class="string">'Password'</span>;</span><br><span class="line"><span class="keyword">let</span> encrypted = aesEncrypted(data, key);</span><br><span class="line"><span class="keyword">let</span> decrypted = aesDecrypted(encrypted, key);</span><br></pre></td></tr></table></figure>
<p>RSA 加解密，非对称加密</p>
<p>首先得到对应的公钥和私钥</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>),</span><br><span class="line">    crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadKey</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fs.readFileSync(file, <span class="string">'utf8'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> prvKey = loadKey(<span class="string">'./rsa-prv.pem'</span>),</span><br><span class="line">    pubKey = loadKey(<span class="string">'./rsa-pub.pem'</span>),</span><br><span class="line">    message = <span class="string">'Hello, world'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> enc_by_prv = crypto.privateEncrypt(prvKey, Buffer.from(message, <span class="string">'utf8'</span>));</span><br><span class="line"><span class="comment">//enc_by_prv.toString('hex');</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dec_by_pub = crypto.publicDecrypt(pubKey, enc_by_prv);</span><br><span class="line"><span class="comment">//dec_by_pub.toString('utf8');</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//然后还可以反过来对称加密</span></span><br></pre></td></tr></table></figure>
<p>5) category 里添加属性</p>
<p>category 它是在<strong>运行期编译</strong>的时候加上的，编译完成后对象内存已经确定，不能添加“_”的成员变量。</p>
<p>runtime 能添加对象的原因是因为：关联对象由AssociationsManager 管理，AssociationManager 里面是一个静态AssociationsHashMap 来存储所有的关联对象的。所以直接保存新的关联对象kv键值对即能添加成功。</p>
<p>6) autoreleasepool</p>
<p>autoreleasepool本质上就是一个指针堆栈</p>
<p>@autoreleasepool{} 其实是实现了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void *poolToken = objc_autoreleasePoolPush();</span><br><span class="line">objc_autoreleasePoolPop(poolToken);</span><br></pre></td></tr></table></figure>
<p>7) KVC KVO深入研究</p>
<p><a href="https://www.jianshu.com/p/37a92141077e" target="_blank" rel="noopener">参考博客</a></p>
<p>KVC 运用isa-swizzling 类型混合指针机制。</p>
<p>[site setValue:@”sitename” forKey:@”name”]; -&gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SEL sel = sel_get_uid(&quot;setValue:forKey:&quot;);</span><br><span class="line">IMP method = objc_msg_lookup(site-&gt;isa, sel);</span><br><span class="line">method(site, sel, @&quot;sitename&quot;, @&quot;name&quot;);</span><br></pre></td></tr></table></figure>
<p>KVC实现分三步.Step1:根据方法名找到运行方法所需要的环境参数；Step2:从自己isa指针结合参数找到具体方法实现接口；Step3:直接查找得来具体方法实现。</p>
<p>KVO在这篇文章能很好的解释<a href="https://www.jianshu.com/p/d657ad764aaa" target="_blank" rel="noopener">博客</a></p>
<p>KVO后续。。。</p>
<h3 id="系统默认注册5个Mode"><a href="#系统默认注册5个Mode" class="headerlink" title="系统默认注册5个Mode:"></a>系统默认注册5个Mode:</h3><ol>
<li>kCFRunLoopDefaultMode:App 默认Mode，主线程。</li>
<li>UITrackingRunLoopMode:界面跟踪Mode，ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode 影响。</li>
<li>UIInitializationRunLoopMode:在刚启动App时进入的第一个Mode, 启动完成后就不在使用。</li>
<li>GSEventReceiveRunLoopMode:接受系统时间内部Mode,通常用不到。</li>
<li>kCFRunLoopCommonModes</li>
</ol>
<p>–</p>
<p>NSTimer 对象以NSDefaultRunLoopMode(kCFRunLoopDefaultMode) 添加到主运行循环后，滑动scrollView NSTimer 却不动了？</p>
<blockquote>
<p>NSTimer 是在defaultRunLoop 调用消息的，当我们滑动scrollview 的时候, NSDefaultRunLoopMode 模式自动切换成UITrackingRunLoopMode 下。所以NSTimer 需要在NSRunLoopCommonMode</p>
</blockquote>
<h3 id="RunTime-添加类、方法、实例变量"><a href="#RunTime-添加类、方法、实例变量" class="headerlink" title="RunTime 添加类、方法、实例变量"></a>RunTime 添加类、方法、实例变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class myClass = objc_allocateClassPair([NSObject class], &quot;Person&quot;, 0);</span><br><span class="line"></span><br><span class="line">class_addMethod 其中types参数为&quot;i@:@“，按顺序分别表示：具体类型可参照[官方文档](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html)i </span><br><span class="line">返回值类型int，若是v则表示void@ 参数id(self): SEL(_cmd)@ id(str)</span><br><span class="line">  V@:表示返回值是void 带有SEL参数 （An object (whether statically typed or typed id)</span><br><span class="line"></span><br><span class="line">class_addMethod(myClass, @selector(addMethodForMyClass:), (IMP)addMethodForMyClass, &quot;V@:&quot;);</span><br><span class="line"></span><br><span class="line">BOOL isSuccess = class_addIvar(myClass, &quot;name&quot;, sizeof(NSString *), 0, &quot;@&quot;);</span><br></pre></td></tr></table></figure>
<h3 id="探讨atomic-一定是线程安全么"><a href="#探讨atomic-一定是线程安全么" class="headerlink" title="探讨atomic 一定是线程安全么"></a>探讨atomic 一定是线程安全么</h3><p>atomic 是在getter 和setter 存取方法的线程保证原子性，并不能保证整个对象的存取动作是线程安全的。</p>
<p>在不同线程中写、读同一个对象，虽然写、读过程是原子性，但是由于等待之后，得到被修改的对象，还是：最终结果属于不可预测。</p>
<p>要保证存、读可预测，可使用下面几个api锁住存取动作，保证线程安全、可预测：</p>
<p>NSLock/NSLockLock/@synchronized(obj){}/pthread_mutex_t/OSSPinLock</p>
<p>其中性能比较:</p>
<p>OSSPinLock &gt; pthread_mutex_t &gt; NSLockLock &gt; NSLock &gt; @synchronized</p>
<h3 id="读YY作者提的几点优化TableView-效率"><a href="#读YY作者提的几点优化TableView-效率" class="headerlink" title="读YY作者提的几点优化TableView 效率"></a>读YY作者提的几点优化TableView 效率</h3><p>对于GPU 等待显示器在一次VSync 时间内，CPU 或者GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次VSync 再显示，而这时显示器就保留了之前的内容不变，这就是界面卡顿的原因。</p>
<p>CPU 应该优化处理的几个点：</p>
<ol>
<li>对象创建</li>
<li>对象调整：frame、bounds 会对CALayer 绘制、创建动画等有比较大开销</li>
<li>对象销毁，可以用一个小Tip：把对象捕获到block 中，然后扔到后台队列去销毁：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSArray *tmp = self.array;</span><br><span class="line">self.array = nil;</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    [tmp class];</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>布局计算</li>
<li>Autolayout（复杂试图尽量使用其他如ComponentKit、AsyncDisplayKit 代替）</li>
<li>文本计算（尽量缓存）</li>
<li>文本渲染</li>
<li>图片解码</li>
<li>图像绘制（CoreGraphic 是线程安全的，可以放到后台进行绘制）</li>
</ol>
<h3 id="最近在搞React-Mobx-这一套"><a href="#最近在搞React-Mobx-这一套" class="headerlink" title="最近在搞React + Mobx 这一套"></a>最近在搞React + Mobx 这一套</h3><p>我已经确定使用这套组合了。因为直接使用vue 感觉没有成就感。React 函数式 + 初学Mobx 的便利(redux 实在是太繁琐了，很多例子很被他绕晕了，真的真的放弃，虽然已经有点入门redux 了；)</p>
<p>html首先碰到</p>
<p>第一个问题:<code>Warning: A component is changing an uncontrolled input of type checkbox</code></p>
<p>原因是我的(input:checkbox) 在checkd时出现传递了undefined 进去，需要判别一下:<code>(this.props.todo.finished === null ||this.props.todo.finished === undefined) ? false : this.props.todo.finished</code></p>
<p>第二个问题:<code>Warning: Each child in an array or iterator should have a unique &quot;key&quot;</code></p>
<p>原因是在组件内部如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&#123;for(...)&#123;&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>有for循环，那么需要给里面的子控件加上key={aString} 的参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &#123;this.props.todolist.todos.map(todo =&gt; (</span><br><span class="line">        &lt;TodoView todo=&#123;todo&#125; key=&#123;todo.id.toString()&#125;&gt;&lt;/TodoView&gt;</span><br><span class="line">    ))&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

  </article>
  <footer class="f-cf">
    
      <a href="/2018/10/29/2018-10-17lesson/" class="link f-fl">⟵2018-10-17lesson</a>
    
    
      <a href="/2018/09/16/2018-9-16lesson-md/" class="link f-fr">2018-9-16lesson.md⟶</a>
    
  </footer>
</section></div>
    <footer id="footer" class="f-cf">
  d.guangying@foxmail.com
  
    
      
        · <a href="https://dribbble.com/clovertuan" target="_blank" class="nav-icn">Dribbble</a>
      
    
      
        · <a href="https://www.behance.net/clovertuan" target="_blank" class="nav-icn">Behance</a>
      
    
      
        · <a href="http://clovertuan.lofter.com/" target="_blank" class="nav-icn">Lofter</a>
      
    
      
        · <a href="https://www.instagram.com/clovertuan/" target="_blank" class="nav-icn">Instagram</a>
      
    
      
        · <a href="https://github.com/cloverTuan" target="_blank" class="nav-icn">GitHub</a>
      
    
  
  <span class="copyright">All rights reserved @Clover Tuan</span>
</footer>
  </div>
</body>
</html>