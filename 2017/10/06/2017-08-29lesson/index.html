<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>2017-08-29lesson | aKer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="2017/8/29123456789101112NSURL *url = [NSURL URLWithString: @&amp;quot;http://www.baidu.com/s?tn=baiduhome_pg&amp;amp;bs=NSRUL&amp;amp;f=8&amp;amp;rsv_bp=1&amp;amp;rsv_spt=1&amp;amp;wd=NSurl&amp;amp;inputT=2709&amp;quot;];  NSLog(@&amp;q">
<meta property="og:type" content="article">
<meta property="og:title" content="2017-08-29lesson">
<meta property="og:url" content="https://akerdi.github.io/2017/10/06/2017-08-29lesson/index.html">
<meta property="og:site_name" content="aKer">
<meta property="og:description" content="2017/8/29123456789101112NSURL *url = [NSURL URLWithString: @&amp;quot;http://www.baidu.com/s?tn=baiduhome_pg&amp;amp;bs=NSRUL&amp;amp;f=8&amp;amp;rsv_bp=1&amp;amp;rsv_spt=1&amp;amp;wd=NSurl&amp;amp;inputT=2709&amp;quot;];  NSLog(@&amp;q">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2023-03-07T09:24:38.365Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="2017-08-29lesson">
<meta name="twitter:description" content="2017/8/29123456789101112NSURL *url = [NSURL URLWithString: @&amp;quot;http://www.baidu.com/s?tn=baiduhome_pg&amp;amp;bs=NSRUL&amp;amp;f=8&amp;amp;rsv_bp=1&amp;amp;rsv_spt=1&amp;amp;wd=NSurl&amp;amp;inputT=2709&amp;quot;];  NSLog(@&amp;q">
  
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
  <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      document.querySelectorAll('pre code').forEach((block) => {
        hljs.highlightBlock(block);
      });
    });
  </script>
  <link rel="stylesheet" href="/css/index.css">
</head>
</html>
<body style="


  background-color: #eff0f6

">
  <div id="container">
    <nav id="nav">
  <header class="header">
    <a href="/" class="title">Clover Tuan</a>
  </header>
  <div class="ctnWrap">
    <div class="icons">
      
        
          
            <a href="https://dribbble.com/clovertuan" target="_blank" class="nav-icn iconfont icon-dribbble"></a>
          
        
          
            <a href="https://www.behance.net/clovertuan" target="_blank" class="nav-icn iconfont icon-behance"></a>
          
        
          
            <a href="http://clovertuan.lofter.com/" target="_blank" class="nav-icn iconfont icon-lofter"></a>
          
        
          
            <a href="https://www.instagram.com/clovertuan/" target="_blank" class="nav-icn iconfont icon-instagram"></a>
          
        
          
            <a href="https://github.com/cloverTuan" target="_blank" class="nav-icn iconfont icon-github"></a>
          
        
      
    </div>
    <div class="menu">
      
        
            <a href="/" class="nav-menu ">HOME</a>
          
        
            <a href="/archives" class="nav-menu ">ARCHIVE</a>
          
        
            <a href="/about" class="nav-menu ">ABOUT</a>
          
        
      
    </div>
  </div>
</nav>
    <div id="main"><section class="article">
  <h2 class="title">2017-08-29lesson</h2>
  <p class="sub">Oct 6, 2017</p>
  <article class="content">
    <p>2017/8/29<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NSURL *url = [NSURL URLWithString: @&quot;http://www.baidu.com/s?tn=baiduhome_pg&amp;bs=NSRUL&amp;f=8&amp;rsv_bp=1&amp;rsv_spt=1&amp;wd=NSurl&amp;inputT=2709&quot;];  </span><br><span class="line">NSLog(@&quot;Scheme: %@&quot;, [url scheme]); </span><br><span class="line">NSLog(@&quot;Host: %@&quot;, [url host]); </span><br><span class="line">NSLog(@&quot;Port: %@&quot;, [url port]);  </span><br><span class="line">NSLog(@&quot;Path: %@&quot;, [url path]);  </span><br><span class="line">NSLog(@&quot;Relative path: %@&quot;, [url relativePath]); </span><br><span class="line">NSLog(@&quot;Path components as array: %@&quot;, [url pathComponents]);   </span><br><span class="line">NSLog(@&quot;Parameter string: %@&quot;, [url parameterString]);  </span><br><span class="line">NSLog(@&quot;Query: %@&quot;, [url query]);   </span><br><span class="line">NSLog(@&quot;Fragment: %@&quot;, [url fragment]); </span><br><span class="line">NSLog(@&quot;User: %@&quot;, [url user]); </span><br><span class="line">NSLog(@&quot;Password: %@&quot;, [url password]);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2012-03-31 18:22:20.904 SmallDemoList[5473:11603] 12131232</span><br><span class="line">2012-03-31 18:22:20.907 SmallDemoList[5473:11603] Scheme: http </span><br><span class="line">2012-03-31 18:22:20.907 SmallDemoList[5473:11603] Host: www.baidu.com </span><br><span class="line">2012-03-31 18:22:20.907 SmallDemoList[5473:11603] Port: (null) </span><br><span class="line">2012-03-31 18:22:20.907 SmallDemoList[5473:11603] Path: /s </span><br><span class="line">2012-03-31 18:22:20.907 SmallDemoList[5473:11603] Relative path: /s </span><br><span class="line">2012-03-31 18:22:20.907 SmallDemoList[5473:11603] Path components as array: ( </span><br><span class="line"> &quot;/&quot;, </span><br><span class="line">) </span><br><span class="line">2012-03-31 18:22:20.916 SmallDemoList[5473:11603] Parameter string: (null) </span><br><span class="line">2012-03-31 18:22:20.917 SmallDemoList[5473:11603] Query: tn=baiduhome_pg&amp;bs=NSRUL&amp;f=8&amp;rsv_bp=1&amp;rsv_spt=1&amp;wd=NSurl&amp;inputT=2709</span><br><span class="line">2012-03-31 18:22:20.917 SmallDemoList[5473:11603] Fragment: (null) </span><br><span class="line">2012-03-31 18:22:20.917 SmallDemoList[5473:11603] User: (null) </span><br><span class="line">2012-03-31 18:22:20.917 SmallDemoList[5473:11603] Password: (null)</span><br></pre></td></tr></table></figure>
<hr>
<p>sourcetree 自己比较常用的<br>1：amand 钩子 对本地的进行amand<br>2：将“xxx”重置到本次提交 - 强行合并 丢弃所有工作副本改动       将本地数据回调到选中版本，删除所有工作副本<br>3：要commit 前，查看所有改动，确认所有改动是否正确</p>
<h3 id="接下来的时间，是时候拆解一个项目，成为一个一个精品轮子了"><a href="#接下来的时间，是时候拆解一个项目，成为一个一个精品轮子了" class="headerlink" title="接下来的时间，是时候拆解一个项目，成为一个一个精品轮子了"></a>接下来的时间，是时候拆解一个项目，成为一个一个精品轮子了</h3><ul>
<li>日记</li>
<li>单位换算</li>
<li>BMI</li>
<li>手账</li>
<li>给他们写一个小型聊天demo</li>
</ul>
<h3 id="记一次输入键盘-在inputView替换状态resignKeyboard-出现的问题"><a href="#记一次输入键盘-在inputView替换状态resignKeyboard-出现的问题" class="headerlink" title="记一次输入键盘 在inputView替换状态resignKeyboard 出现的问题"></a>记一次输入键盘 在inputView替换状态resignKeyboard 出现的问题</h3><p>其中在 emoji状态，如果resign 那么其会走 showKeyboard 和hideKeyboard ，由于keyboard 比较慢，，会出现completion 最慢，，最后导致界面不能滑动</p>
<h3 id="导航栏的几种推栈、退栈"><a href="#导航栏的几种推栈、退栈" class="headerlink" title="导航栏的几种推栈、退栈"></a>导航栏的几种推栈、退栈</h3><ol>
<li>没导航栏-&gt;有导航栏   没导航栏&lt;-有导航栏</li>
<li>有导航栏-&gt;有导航栏   有导航栏&lt;-有导航栏</li>
<li>没导航栏-&gt;没导航栏   没导航栏&lt;-没导航栏</li>
</ol>
<p>这一类都是需要注意的一个地方，在viewwillApeare 和viewWillDisapear 2个方法里面的对应2个方法优化:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.navigationController.navigationBarHidden = YES;</span><br><span class="line">[self.navigationController setNavigationBarHidden:YES animated:animated];</span><br></pre></td></tr></table></figure></p>
<h3 id="日期格式"><a href="#日期格式" class="headerlink" title="日期格式"></a>日期格式</h3><p><a href="http://www.cnblogs.com/wayne23/archive/2013/03/25/2981009.html" target="_blank" rel="noopener">http://www.cnblogs.com/wayne23/archive/2013/03/25/2981009.html</a></p>
<p>时间与日期处理</p>
<p>主要有以下类：<br>NSDate – 表示一个绝对的时间点<br>NSTimeZone – 时区信息<br>NSLocale – 本地化信息<br>NSDateComponents – 一个封装了具体年月日、时秒分、周、季度等的类<br>NSCalendar – 日历类，它提供了大部分的日期计算接口，并且允许您在NSDate和NSDateComponents之间转换<br>NSDateFormatter – 用来在日期和字符串之间转换</p>
<p>NSDate</p>
<p>NSDate用来表示公历的GMT时间(格林威治时间)。 有下面几种初始化方法：</p>
<ol>
<li><ul>
<li>(id)init</li>
</ul>
</li>
</ol>
<p>默认初始化，返回当前时间，也可以直接调用类方法 +(id)date</p>
<p>NSDate <em>date = [[NSDate alloc] init];<br>//NSDate </em>date = [NSDate date];<br>NSLog(@”print date is %@”,date);<br>将打印出计算机当前时间：2013-03-04 08:57:20 +0000</p>
<ol start="2">
<li><ul>
<li>(id)initWithTimeIntervalSinceNow:(NSTimeInterval)seconds</li>
</ul>
</li>
</ol>
<p>以当前时间的偏移秒数来初始化，也可以直接调用类方法 + (id)dateWithTimeIntervalSinceNow:(NSTimeInterval)seconds</p>
<p>NSDate <em>date = [[NSDate alloc] initWithTimeIntervalSinceNow:20];<br>//NSDate </em>date = [NSDate dateWithTimeIntervalSinceNow:20];<br>NSLog(@”print date is %@”,date);<br>假如当前时间是2013-03-04 08:57:20 +0000，那么初始化后得到的时间是2013-03-04 08:57:40 +0000</p>
<ol start="3">
<li><ul>
<li>(id)initWithTimeIntervalSince1970:(NSTimeInterval)seconds</li>
</ul>
</li>
</ol>
<p>以GMT时间的偏移秒数来初始化，也可以直接调用类方法 + (id)dateWithTimeIntervalSince1970:(NSTimeInterval)seconds</p>
<p>NSDate <em>date = [[NSDate alloc] initWithTimeIntervalSince1970:-20];<br>//NSDate </em>date = [NSDate dateWithTimeIntervalSince1970:-20];<br>NSLog(@”print date is %@”,date);<br>得到的时间是格林威治时间往前20秒，将打印出：1969-12-31 23:59:40 +0000</p>
<ol start="4">
<li><ul>
<li>(id)initWithTimeIntervalSinceReferenceDate:(NSTimeInterval)seconds</li>
</ul>
</li>
</ol>
<p>以2001-1-1 0:0:0的偏移秒数来初始化，也可以直接调用类方法 + (id)dateWithTimeIntervalSinceReferenceDate:(NSTimeInterval)seconds</p>
<p>NSDate <em>date = [[NSDate alloc] initWithTimeIntervalSinceReferenceDate:80];<br>//NSDate </em>date = [NSDate dateWithTimeIntervalSinceReferenceDate:80];<br>NSLog(@”print date is %@”,date);<br>将打印出：2001-01-01 00:01:20 +0000</p>
<ol start="5">
<li><ul>
<li>(id)initWithTimeInterval:(NSTimeInterval)seconds sinceDate:(NSDate *)refDate</li>
</ul>
</li>
</ol>
<p>以基准时间的偏移秒数来初始化，也可以直接调用类方法 + (id)dateWithTimeInterval:(NSTimeInterval)seconds sinceDate:(NSDate *)date</p>
<p>复制代码<br>NSDate *date1 = [[NSDate alloc] initWithTimeIntervalSinceReferenceDate:20];<br>NSLog(@”print date1 is %@”,date1);</p>
<p>NSDate <em>date2 = [[NSDate alloc] initWithTimeInterval:10 sinceDate:date1];<br>//NSDate </em>date2 = [NSDate dateWithTimeInterval:10 sinceDate:date1];<br>NSLog(@”print date2 is %@”,date2);<br>复制代码<br>第一个基准时间是2001-01-01 00:00:20 +0000，根据基准时间偏移10秒的结果是2001-01-01 00:00:30 +0000</p>
<ol start="6">
<li><ul>
<li>(id)distantPast 与 + (id)distantFuture</li>
</ul>
</li>
</ol>
<p>这两个是类方法，分别用来返回一个极早的时间点和一个极晚的时间点</p>
<p>NSDate *date = [NSDate distantFuture];<br>NSLog(@”future date is %@”,date);</p>
<p>NSDate *date2 = [NSDate distantPast];<br>NSLog(@”past date is %@”,date2);<br>distantPast将返回：0001-12-30 00:00:00 +0000，distantFuture将返回：4001-01-01 00:00:00 +0000</p>
<p>NSDate的常用对象方法：</p>
<ol>
<li>-(id)dateByAddingTimeInterval:(NSTimeInterval)seconds</li>
</ol>
<p>返回以当前NSDate对象为基准，偏移多少秒后得到的新NSDate对象。(旧方法 - (id)addTimeInterval:(NSTimeInterval)seconds已被弃用)</p>
<p>NSDate <em>date = [NSDate dateWithTimeIntervalSince1970:0];<br>NSDate </em>date2 = [date dateByAddingTimeInterval:-20];<br>NSLog(@”%@”,date2);</p>
<ol start="2">
<li><ul>
<li>(BOOL)isEqualToDate:(NSDate *)anotherDate</li>
</ul>
</li>
</ol>
<p>将当前对象与参数传递的对象进行比较，根据是否相同返回BOOL值</p>
<p>NSDate <em>date = [NSDate dateWithTimeIntervalSince1970:0];<br>NSDate </em>date2 = [NSDate dateWithTimeInterval:0 sinceDate:date];<br>BOOL isEqual = [date isEqualToDate:date2];<br>NSLog(@”%i”,isEqual);</p>
<ol start="3">
<li><ul>
<li>(NSDate <em>)earlierDate:(NSDate </em>)anotherDate 与 - (NSDate <em>)laterDate:(NSDate </em>)anotherDate</li>
</ul>
</li>
</ol>
<p>比较两个NSDate对象，返回较早/较晚的时间点，并以新NSDate对象的形式返回</p>
<p>复制代码<br>NSDate <em>date = [NSDate dateWithTimeIntervalSince1970:0];<br>NSDate </em>date2 = [NSDate dateWithTimeInterval:-50 sinceDate:date];</p>
<p>NSDate *date3 = [date earlierDate:date2];<br>NSLog(@”earlier date is %@”,date3);</p>
<p>NSDate *date4 = [date laterDate:date2];<br>NSLog(@”later date is %@”,date4);<br>复制代码</p>
<ol start="4">
<li><ul>
<li>(NSComparisonResult)compare:(NSDate *)anotherDate</li>
</ul>
</li>
</ol>
<p>将当前对象与参数传递的对象进行比较，如果相同，返回0(NSOrderedSame)；对象时间早于参数时间，返回-1(NSOrderedAscending)；对象时间晚于参数时间，返回1(NSOrderedDescending)</p>
<p>NSDate <em>date = [NSDate dateWithTimeIntervalSince1970:0];<br>NSDate </em>date2 = [NSDate dateWithTimeInterval:-50 sinceDate:date];</p>
<p>NSInteger result = [date compare:date2];<br>NSLog(@”%i”,result);</p>
<ol start="5">
<li><ul>
<li>(NSTimeInterval)timeIntervalSince1970</li>
</ul>
</li>
</ol>
<p>返回当前对象时间与1970-1-1 0:0:0的相隔秒数，也可以这样理解：从1970-1-1 0:0:0开始，经过多少秒到达对象指定时间。</p>
<p>NSDate *date = [NSDate dateWithTimeIntervalSince1970:50];<br>NSInteger seconds = [date timeIntervalSince1970];<br>NSLog(@”%i”,seconds);<br>将返回结果50</p>
<ol start="6">
<li><ul>
<li>(NSTimeInterval)timeIntervalSinceReferenceDate</li>
</ul>
</li>
</ol>
<p>返回当前对象时间与2001-1-1 0:0:0的相隔秒数，也可以这样理解：从2001-1-1 0:0:0开始，经过多少秒到达对象指定时间。</p>
<p>NSDate *date = [NSDate dateWithTimeIntervalSinceReferenceDate:-30];<br>NSInteger seconds = [date timeIntervalSinceReferenceDate];<br>NSLog(@”%i”,seconds);<br>将返回结果-30，负数代表从2001-1-1 0:0:0开始，倒退30秒到达当前时间。</p>
<ol start="7">
<li><ul>
<li>(NSTimeInterval)timeIntervalSinceNow</li>
</ul>
</li>
</ol>
<p>返回当前对象时间与客户端时间的相隔秒数，也可以这样理解：从客户端当前时间开始，经过多少秒到达对象指定时间。</p>
<p>NSDate *date = [NSDate dateWithTimeIntervalSinceNow:100];<br>NSInteger seconds = [date timeIntervalSinceNow];<br>NSLog(@”%i”,seconds);<br>经测试返回了结果99，但初始化时提供的参数是100。这可能是因为第一句初始化代码到第二句计算代码之间有个1秒内的延时，所以计算时的客户端时间比初始化时的客户端时间快了1秒。</p>
<ol start="8">
<li><ul>
<li>(NSTimeInterval)timeIntervalSinceDate:(NSDate *)anotherDate</li>
</ul>
</li>
</ol>
<p>返回当前对象时间与参数传递的对象时间的相隔秒数，也可以这样理解：从参数时间开始，经过多少秒到达对象执行时间。</p>
<p>NSDate <em>date = [NSDate dateWithTimeIntervalSince1970:0];<br>NSDate </em>date2 = [NSDate dateWithTimeInterval:50 sinceDate:date];<br>NSInteger seconds = [date timeIntervalSinceDate:date2];<br>NSLog(@”%i”,seconds);<br>将返回结果-50，date为1970-1-1 0:0:0，date2为1970-1-1 0:0:50，从date2的时间开始，倒退50秒到达date的时间。</p>
<p>NSTimeZone</p>
<p>NSTimeZone表示时区信息。 有下面几种初始化方法：</p>
<ol>
<li><ul>
<li>(id)timeZoneWithName:(NSString <em>)aTimeZoneName / - (id)initWithName:(NSString </em>)aName</li>
</ul>
</li>
</ol>
<p>根据时区名称初始化。可以调用NSTimeZone的类方法 + (NSArray *)knownTimeZoneNames来返回所有已知的时区名称。</p>
<p>NSTimeZone <em>zone = [[NSTimeZone alloc] initWithName:@”America/Chicago”];<br>//NSTimeZone </em>zone = [NSTimeZone timeZoneWithName:@”America/Chicago”];<br>NSLog(@”%@”,zone);<br>打印出：America/Chicago (CST) offset -21600</p>
<ol start="2">
<li><ul>
<li>(id)timeZoneWithAbbreviation:(NSString *)abbreviation</li>
</ul>
</li>
</ol>
<p>根据时区缩写初始化。例如：EST(美国东部标准时间)、HKT(香港标准时间)</p>
<p>NSTimeZone *zone = [NSTimeZone timeZoneWithAbbreviation:@”EST”];<br>NSLog(@”%@”,zone);<br>打印出：Asia/Hong_Kong (HKT) offset 28800</p>
<ol start="3">
<li><ul>
<li>(NSTimeZone *)systemTimeZone</li>
</ul>
</li>
</ol>
<p>返回系统时区</p>
<p>NSTimeZone <em>zone = [NSTimeZone systemTimeZone];<br>NSLog(@”%@”,zone);<br>假如时区是上海，打印出的时区信息将会是：Asia/Shanghai (CST (China)) offset 28800，28800代表相对于GMT时间偏移的秒数，即8个小时。(8</em>60*60)</p>
<ol start="4">
<li><ul>
<li>(NSTimeZone *)localTimeZone</li>
</ul>
</li>
</ol>
<p>返回本地时区，与systemTimeZone的区别在于：本地时区可以被修改，而系统时区不能修改。</p>
<p>复制代码<br>[NSTimeZone setDefaultTimeZone:[[NSTimeZone alloc] initWithName:@”America/Chicago”]];</p>
<p>NSTimeZone <em>systemZone = [NSTimeZone systemTimeZone];<br>NSTimeZone </em>localZone = [NSTimeZone localTimeZone];</p>
<p>NSLog(@”%@”,systemZone);<br>NSLog(@”%@”,localZone);<br>复制代码<br>打印出的系统时区仍然是：Asia/Shanghai (CST (China)) offset 28800；而本地时区经过修改后，变成了：Local Time Zone (America/Chicago (CST) offset -21600)</p>
<ol start="5">
<li><ul>
<li>(id)timeZoneForSecondsFromGMT:(NSInteger)seconds</li>
</ul>
</li>
</ol>
<p>根据零时区的秒数偏移返回一个新时区对象</p>
<p>NSTimeZone *zone = [NSTimeZone timeZoneForSecondsFromGMT:28800];<br>NSLog(@”%@”,zone);<br>打印出：GMT+0800 (GMT+08:00) offset 28800</p>
<p>NSTimeZone常用对象方法与类方法：</p>
<ol>
<li><ul>
<li>(NSArray *)knownTimeZoneNames</li>
</ul>
</li>
</ol>
<p>以数组的形式返回所有已知的时区名称</p>
<p>NSArray <em>zoneArray = [NSTimeZone knownTimeZoneNames];<br>for(NSString </em>str in zoneArray)<br>{<br>    NSLog(@”%@”,str);<br>}</p>
<ol start="2">
<li><ul>
<li>(NSString <em>)name / - (NSString </em>)abbreviation</li>
</ul>
</li>
</ol>
<p>返回时区对象的名称或缩写</p>
<p>NSTimeZone <em>zone = [NSTimeZone localTimeZone];<br>NSString </em>strZoneName = [zone name];<br>NSString *strZoneAbbreviation = [zone abbreviation];<br>NSLog(@”name is %@”,strZoneName);<br>NSLog(@”abbreviation is %@”,strZoneAbbreviation);<br>name is Asia/Hong_Kong</p>
<p>abbreviation is HKT</p>
<ol start="3">
<li><ul>
<li>(NSInteger)secondsFromGMT</li>
</ul>
</li>
</ol>
<p>得到当前时区与零时区的间隔秒数</p>
<p>NSTimeZone *zone = [NSTimeZone localTimeZone];<br>int seconds = [zone secondsFromGMT];<br>NSLog(@”%i”,seconds);<br>NSLoale</p>
<p>NSLoale类返回本地化信息，主要体现在”语言”和”区域格式”这两个设置项。有下面几种初始化方法：</p>
<ol>
<li><ul>
<li>(id)systemLocale</li>
</ul>
</li>
</ol>
<p>返回系统初始本地化信息</p>
<p>NSLocale *locale = [NSLocale systemLocale];<br>NSLog(@”%@”,[[locale objectForKey:NSLocaleCalendar] calendarIdentifier]);</p>
<ol start="2">
<li><ul>
<li>(id)currentLocale / + (id)autoupdatingCurrentLocale</li>
</ul>
</li>
</ol>
<p>这两个类方法都将返回当前客户端的本地化信息，区别在于：currentLocale取得的值会一直保持在cache中，第一次用此方法实例化对象后，即使修改了本地化设定，这个对象也不会改变。而使用autoupdatingCurrentLocale，当每次修改本地化设定，其实例化的对象也会随之改变。</p>
<p>下面的代码演示了区别所在，假设初始本地化信息为en_US，先用这两个函数分别初始化两个对象，然后修改本地化设定语言为台湾繁体中文，再重新打印这两个对象的信息：</p>
<p>复制代码<br>NSLocale <em>locale1;<br>NSLocale </em>locale2;</p>
<ul>
<li><p>(IBAction)doTest:(id)sender<br>{<br>  locale1 = [NSLocale currentLocale];<br>  locale2 = [NSLocale autoupdatingCurrentLocale];</p>
<p>  NSLog(@”%@”,locale1.localeIdentifier); //print “en_US”<br>  NSLog(@”%@”,locale2.localeIdentifier); //print “en_US”<br>}</p>
</li>
<li><p>(IBAction)doAgain:(id)sender<br>{<br>  NSLog(@”%@”,locale1.localeIdentifier); //print “en_US”<br>  NSLog(@”%@”,locale2.localeIdentifier); //print “zh_TW”<br>}<br>复制代码</p>
</li>
</ul>
<ol start="3">
<li><ul>
<li>(id)initWithLocaleIdentifier:(NSString *)string</li>
</ul>
</li>
</ol>
<p>用标示符初始化本地化信息</p>
<p>NSLocale <em>locale = [[NSLocale alloc] initWithLocaleIdentifier:@”zh_CN”];<br>NSString </em>strSymbol = [locale objectForKey:NSLocaleCurrencySymbol];<br>NSLog(@”%@”,strSymbol);<br>代码用”zh_CN”来初始化对象，然后再打印出对象的货币符号，得到的结果是人民币符号￥</p>
<p>NSLoale常用对象方法与类方法：</p>
<ol>
<li><ul>
<li>(id)objectForKey:(id)key</li>
</ul>
</li>
</ol>
<p>根据不同的key返回各种本地化信息，例如下面的代码返回了当前货币符号：</p>
<p>NSLocale <em>locale = [NSLocale currentLocale];<br>NSString </em>strSymbol = [locale objectForKey:NSLocaleCurrencySymbol];<br>NSCalendar *calendar = [[NSLocale currentLocale] objectForKey:NSLocaleCalendar];</p>
<ol start="2">
<li><ul>
<li>(NSString *)displayNameForKey:(id)key value:(id)value</li>
</ul>
</li>
</ol>
<p>显示特定地区代号下相应键的显示名称：</p>
<p>NSLocale <em>locale = [[NSLocale alloc] initWithLocaleIdentifier:@”zh_CN”];<br>NSString </em>str = [locale displayNameForKey:NSLocaleIdentifier value:@”en_US”];<br>NSLog(@”%@”,str);<br>第一句代码代表以中文来实例化对象，然后得到”en_US”的NSLocaleIdentifier键的显示名称。最后输出的结果是”英文（美国）”</p>
<p>NSDateComponents</p>
<p>NSDateComponents封装了具体年月日、时秒分、周、季度等</p>
<p>复制代码<br>NSDateComponents *compt = [[NSDateComponents alloc] init];<br>[compt setEra:1];<br>[compt setYear:2013];<br>[compt setMonth:3];<br>[compt setDay:15];<br>[compt setHour:11];<br>[compt setMinute:20];<br>[compt setSecond:55];<br>[compt setQuarter:2];<br>[compt setTimeZone:[NSTimeZone systemTimeZone]];<br>[compt setWeek:3];<br>[compt setWeekday:4];<br>[compt setWeekOfMonth:3];<br>[compt setWeekOfYear:2];<br>[compt setCalendar:[NSCalendar currentCalendar]];<br>复制代码<br>NSDateComponents相关方法：</p>
<ol>
<li>NSCalendar对象的 - (NSDateComponents <em>)components:(NSUInteger)unitFlags fromDate:(NSDate </em>)date</li>
</ol>
<p>取得一个NSDate对象的1个或多个部分，用NSDateComponents来封装</p>
<p>复制代码<br>NSCalendar <em>calendar = [NSCalendar currentCalendar];<br>NSDate </em>date = [NSDate date];<br>//NSDateComponents <em>compt = [calendar components:NSDayCalendarUnit fromDate:date];<br>NSDateComponents </em>compt = [calendar components:(NSYearCalendarUnit|NSMonthCalendarUnit|NSDayCalendarUnit) fromDate:date];</p>
<p>NSLog(@”%d,%@”,[compt year],date);<br>NSLog(@”%d,%@”,[compt month],date);<br>NSLog(@”%d,%@”,[compt day],date);<br>复制代码<br>需要注意的是，只有明确指定了unitFlags，NSDateComponents相应的那一部分才有值。</p>
<ol start="2">
<li>NSCalendar对象的 - (NSDateComponents <em>)components:(NSUInteger)unitFlags fromDate:(NSDate </em>)startingDate toDate:(NSDate *)resultDate options : (NSUInteger)opts</li>
</ol>
<p>取得两个NSDate对象的时间间隔，用NSDateComponents来封装</p>
<p>复制代码<br>NSCalendar <em>calendar = [NSCalendar currentCalendar];<br>NSDate </em>date = [NSDate date];<br>NSDate <em>date2 = [NSDate dateWithTimeInterval:5</em>60<em>60+75 sinceDate:date];<br>NSDateComponents </em>compt = [calendar components:(NSMinuteCalendarUnit|NSSecondCalendarUnit) fromDate:date toDate:date2 options:0];</p>
<p>NSLog(@”%d”,[compt minute]);<br>NSLog(@”%d”,[compt second]);<br>复制代码<br>有几点需要注意：</p>
<p>① 得到的NSDateComponents对象可能会包含负数。例如：当toDate比fromDate晚10秒，second部分返回10；当toDate比fromDate早10秒，second部分返回-10</p>
<p>② 当指定unitFlags返回多个部分时，相隔的时间由多个部分共同组成(而不是独立去表示)。例如：上面的例子时间相差5小时1分15秒，如果指定只返回second部分，将得到18075秒；如果指定返回minute和second部分，将得到301分15秒；如果指定返回hour、minute和second，将得到5小时1分15秒。</p>
<ol start="3">
<li>NSCalendar对象的 - (NSDate <em>)dateFromComponents:(NSDateComponents </em>)comps</li>
</ol>
<p>根据NSDateComponents对象得到一个NSDate对象</p>
<p>复制代码<br>NSDateComponents *compt = [[NSDateComponents alloc] init];<br>[compt setYear:2012];<br>[compt setMonth:5];<br>[compt setDay:11];</p>
<p>NSCalendar <em>calendar = [NSCalendar currentCalendar];<br>NSDate </em>date = [calendar dateFromComponents:compt];<br>//得到本地时间，避免时区问题<br>NSTimeZone <em>zone = [NSTimeZone systemTimeZone];<br>NSInteger interval = [zone secondsFromGMTForDate:date];<br>NSDate </em>localeDate = [date dateByAddingTimeInterval:interval];</p>
<p>NSLog(@”%@”,localeDate);<br>复制代码</p>
<ol start="4">
<li>NSCalendar对象的 - (NSDate <em>)dateByAddingComponents:(NSDateComponents </em>)comps toDate:(NSDate *)date options:(NSUInteger)opts</li>
</ol>
<p>在参数date基础上，增加一个NSDateComponents类型的时间增量</p>
<p>复制代码<br>NSDateComponents *compt = [[NSDateComponents alloc] init];<br>[compt setDay:25];<br>[compt setHour:4];<br>[compt setMinute:66];</p>
<p>NSCalendar <em>calendar = [NSCalendar currentCalendar];<br>NSDate </em>date = [calendar dateByAddingComponents:compt toDate:[NSDate date] options:0];</p>
<p>//得到本地时间，避免时区问题<br>NSTimeZone <em>zone = [NSTimeZone systemTimeZone];<br>NSInteger interval = [zone secondsFromGMTForDate:date];<br>NSDate </em>localeDate = [date dateByAddingTimeInterval:interval];</p>
<p>NSLog(@”%@”,localeDate);<br>复制代码<br>当前时间的基础上，增加25天4小时66秒</p>
<p>NSCalendar</p>
<ol>
<li><ul>
<li>(id)currentCalendar / + (id)autoupdatingCurrentCalendar</li>
</ul>
</li>
</ol>
<p>这两个类方法都将返回当前客户端的逻辑日历，区别在于：currentCalendar取得的值会一直保持在cache中，第一次用此方法实例化对象后，即使修改了系统日历设定，这个对象也不会改变。而使用autoupdatingCurrentCalendar，当每次修改系统日历设定，其实例化的对象也会随之改变。</p>
<p>下面的代码演示了区别所在，假设初始Calendar设定为NSGregorianCalendar(公历)，先用这两个函数分别初始化两个对象，然后修改系统日历为NSJapaneseCalendar(日本和历)，再重新打印这两个对象的信息：</p>
<p>复制代码<br>NSCalendar <em>calendar;<br>NSCalendar </em>calendar2;</p>
<ul>
<li><p>(IBAction)doTest:(id)sender<br>{<br>  calendar = [NSCalendar currentCalendar];<br>  calendar2 = [NSCalendar autoupdatingCurrentCalendar];</p>
<p>  NSLog(@”%@”,calendar.calendarIdentifier); //print “gregorian”<br>  NSLog(@”%@”,calendar2.calendarIdentifier); //print “gregorian”<br>}</p>
</li>
<li><p>(IBAction)doAgain:(id)sender<br>{<br>  NSLog(@”%@”,calendar.calendarIdentifier); //print “gregorian”<br>  NSLog(@”%@”,calendar2.calendarIdentifier); //print “japanese”<br>}<br>复制代码</p>
</li>
</ul>
<ol start="2">
<li><ul>
<li>(id)initWithCalendarIdentifier:(NSString *)string</li>
</ul>
</li>
</ol>
<p>根据提供的日历标示符初始化</p>
<p>NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSChineseCalendar];<br>NSLog(@”%@”,calendar.calendarIdentifier);<br>系统中定义的日历有：</p>
<p>NSGregorianCalendar – 公历<br>NSBuddhistCalendar – 佛教日历<br>NSChineseCalendar – 中国农历<br>NSHebrewCalendar – 希伯来日历<br>NSIslamicCalendar – 伊斯兰历<br>NSIslamicCivilCalendar – 伊斯兰教日历<br>NSJapaneseCalendar – 日本日历<br>NSRepublicOfChinaCalendar – 中华民国日历（台湾）<br>NSPersianCalendar – 波斯历<br>NSIndianCalendar – 印度日历<br>NSISO8601Calendar – ISO8601</p>
<p>NSCalendar常用对象方法与类方法：</p>
<ol>
<li><ul>
<li>(void)setLocale:(NSLocale *)locale</li>
</ul>
</li>
</ol>
<p>设置本地化信息</p>
<p>NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];<br>[calendar setLocale:[[NSLocale alloc] initWithLocaleIdentifier:@”zh_CN”]];<br>NSLog(@”%@”,calendar.locale.localeIdentifier);</p>
<ol start="2">
<li><ul>
<li>(void)setTimeZone:(NSTimeZone *)tz</li>
</ul>
</li>
</ol>
<p>设置时区信息</p>
<p>NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];<br>[calendar setTimeZone:[NSTimeZone timeZoneWithAbbreviation:@”HKT”]];<br>NSLog(@”%@”,calendar.timeZone);</p>
<ol start="3">
<li><ul>
<li>(void)setFirstWeekday:(NSUInteger)weekday</li>
</ul>
</li>
</ol>
<p>设置每周的第一天从星期几开始，比如：1代表星期日开始，2代表星期一开始，以此类推。默认值是1</p>
<p>如图所示，如果从星期天开始，日历的表现形式：</p>
<p>如果从星期二开始，日历的表现形式：</p>
<p>NSCalendar *calendar = [NSCalendar currentCalendar];<br>[calendar setFirstWeekday:3];<br>NSLog(@”%i”,calendar.firstWeekday);</p>
<ol start="4">
<li><ul>
<li>(void)setMinimumDaysInFirstWeek:(NSUInteger)mdw</li>
</ul>
</li>
</ol>
<p>设置每年及每月第一周必须包含的最少天数，比如：设定第一周最少包括3天，则value传入3</p>
<p>NSCalendar *calendar = [NSCalendar currentCalendar];<br>[calendar setMinimumDaysInFirstWeek:3];<br>NSLog(@”%i”,calendar.minimumDaysInFirstWeek);</p>
<ol start="5">
<li><ul>
<li>(NSUInteger)ordinalityOfUnit:(NSCalendarUnit)smaller inUnit:(NSCalendarUnit)larger forDate:(NSDate *)date</li>
</ul>
</li>
</ol>
<p>获取一个小的单位在一个大的单位里面的序数</p>
<p>NSCalendarUnit包含的值有：</p>
<p>NSEraCalendarUnit – 纪元单位。对于NSGregorianCalendar(公历)来说，只有公元前(BC)和公元(AD)；而对于其它历法可能有很多，例如日本和历是以每一代君王统治来做计算。<br>NSYearCalendarUnit – 年单位。值很大，相当于经历了多少年，未来多少年。<br>NSMonthCalendarUnit – 月单位。范围为1-12<br>NSDayCalendarUnit – 天单位。范围为1-31<br>NSHourCalendarUnit – 小时单位。范围为0-24<br>NSMinuteCalendarUnit – 分钟单位。范围为0-60<br>NSSecondCalendarUnit – 秒单位。范围为0-60<br>NSWeekCalendarUnit – 周单位。范围为1-53<br>NSWeekdayCalendarUnit – 星期单位，每周的7天。范围为1-7<br>NSWeekdayOrdinalCalendarUnit – 没完全搞清楚<br>NSQuarterCalendarUnit – 几刻钟，也就是15分钟。范围为1-4<br>NSWeekOfMonthCalendarUnit – 月包含的周数。最多为6个周<br>NSWeekOfYearCalendarUnit – 年包含的周数。最多为53个周<br>NSYearForWeekOfYearCalendarUnit – 没完全搞清楚<br>NSTimeZoneCalendarUnit – 没完全搞清楚</p>
<p>下面是一些示例：</p>
<p>① 当小单位为NSWeekdayCalendarUnit，大单位为NSWeekCalendarUnit时(即某个日期在这一周是第几天)，根据firstWeekday属性不同，返回的结果也不同。</p>
<p>NSCalendar <em>calendar = [NSCalendar currentCalendar];<br>NSDate </em>date = [NSDate dateWithTimeIntervalSinceReferenceDate:10];<br>//[calendar setFirstWeekday:2];<br>int count = [calendar ordinalityOfUnit:NSWeekdayCalendarUnit inUnit:NSWeekCalendarUnit forDate:date];<br>NSLog(@”%d”,count);<br>默认firstWeekday为1(星期天开始)的情况下，得到的结果是2，从下图可以看到是第2天。</p>
<p>假如firstWeekday被设置为2(星期一开始)的情况下，得到的结果是1，从下图可以看到是第1天</p>
<p>② 当小单位为NSWeekCalendarUnit，大单位为NSYearCalendarUnit时(即某个日期在这一年中是第几周)，根据minimumDaysInFirstWeek属性不同，返回的结果也不同。</p>
<p>复制代码<br>NSDateComponents *compt = [[NSDateComponents alloc] init];<br>[compt setYear:2013];<br>[compt setMonth:1];<br>[compt setDay:20];</p>
<p>NSCalendar *calendar = [NSCalendar currentCalendar];</p>
<p>NSDate *date = [calendar dateFromComponents:compt];</p>
<p>//[calendar setMinimumDaysInFirstWeek:6];<br>int count = [calendar ordinalityOfUnit:NSWeekCalendarUnit inUnit:NSYearCalendarUnit forDate:date];<br>NSLog(@”%d”,count);<br>复制代码<br>从上图的日历中可以看出，在没有设置minimumDaysInFirstWeek的情况下，1月20日得到的结果是4(第四个周)。</p>
<p>默认情况下第一个周有5天，如果将minimumDaysInFirstWeek设置为6天，则原本是第一周的1月1日–1月5日被划分到了上一年，返回0；而1月6日–1月12日升为第一周，1月13日–1月19日升为第二周。。依此类推。</p>
<p>所以需要关注的是minimumDaysInFirstWeek与实际第一周包含天数的大小比较，如果提供的minimumDaysInFirstWeek比实际第一周的天数小，则一切不变；否则统计”一年中第几周”、”一个月中第几周”会产生变化。</p>
<ol start="6">
<li><ul>
<li>(NSRange)rangeOfUnit:(NSCalendarUnit)smaller inUnit:(NSCalendarUnit)larger forDate:(NSDate *)date</li>
</ul>
</li>
</ol>
<p>根据参数提供的时间点，得到一个小的单位在一个大的单位里面的取值范围</p>
<p>复制代码<br>NSDateComponents *compt = [[NSDateComponents alloc] init];<br>[compt setYear:2013];<br>[compt setMonth:2];<br>[compt setDay:21];<br>[compt setHour:9];<br>[compt setMinute:45];<br>[compt setSecond:30];</p>
<p>NSCalendar <em>calendar = [NSCalendar currentCalendar];<br>NSDate </em>date = [calendar dateFromComponents:compt];</p>
<p>//得到本地时间，避免时区问题<br>NSTimeZone <em>zone = [NSTimeZone systemTimeZone];<br>NSInteger interval = [zone secondsFromGMTForDate:date];<br>NSDate </em>localeDate = [date dateByAddingTimeInterval:interval];</p>
<p>NSRange range = [calendar rangeOfUnit:NSDayCalendarUnit inUnit:NSYearCalendarUnit forDate:localeDate];</p>
<p>NSLog(@”%d – %d”,range.location,range.length);<br>复制代码<br>调用这个方法要明确一点，取得的是”范围”而不是”包含”，下面是一些例子：</p>
<p>① 小单位是NSDayCalendarUnit，大单位是NSYearCalendarUnit，并不是要取这一年包含多少天，而是要取”天”(Day)这个单位在这一年(Year)的取值范围。其实不管你提供的日期是多少，返回的值都是”1–31”。</p>
<p>② 小单位是NSDayCalendarUnit，大单位是NSMonthCalendarUnit。要取得参数时间点所对应的月份下，”天”(Day)的取值范围。根据参数时间的月份不同，值也不同。例如2月是1–28、3月是1–31、4月是1–30。</p>
<p>③ 小单位是NSWeekCalendarUnit，大单位是NSMonthCalendarUnit。要取得参数时间点所对应的月份下，”周”(Week)的取值范围。需要注意的是结果会受到minimumDaysInFirstWeek属性的影响。在默认minimumDaysInFirstWeek情况下，取得的范围值一般是”1–5”，从日历上可以看出来这个月包含5排，即5个周。</p>
<p>④ 小单位是NSDayCalendarUnit，大单位是NSWeekCalendarUnit。要取得周所包含的”天”(Day)的取值范围。下面是一个示例日历图：</p>
<p>在上图的日期条件下，假如提供的参数是4月1日–4月6日，那么对应的week就是1(第一个周)，可以看到第一个周包含有6天，从1号开始，那么最终得到的范围值为1–6。</p>
<p>假如提供的参数是4月18日，那么对应的week是3(第三个周)，第三个周包含有7天，从14号开始，那么最终得到的范围值是14–7。</p>
<p>假如提供的参数是4月30日，那么对应的week是5(第五个周)，第五个周只包含3天，从28号开始，那么最终得到的范围值是28–3。</p>
<ol start="7">
<li><ul>
<li>(BOOL)rangeOfUnit:(NSCalendarUnit)unit startDate:(NSDate *<em>)datep interval:(NSTimeInterval </em>)tip forDate:(NSDate *)date</li>
</ul>
</li>
</ol>
<p>根据参数提供的时间点，返回所在日历单位的开始时间。如果startDate和interval均可以计算，则返回YES；否则返回NO</p>
<p>unit – 日历单位<br>datep – 开始时间，通过参数返回<br>tip – 日历单位所对应的秒数，通过参数返回<br>date – 时间点参数</p>
<p>复制代码<br>NSDate *dateOut = nil;<br>NSTimeInterval count = 0;</p>
<p>NSDateComponents *compt = [[NSDateComponents alloc] init];<br>[compt setYear:2013];<br>[compt setMonth:3];<br>[compt setDay:22];</p>
<p>NSCalendar <em>calendar = [NSCalendar currentCalendar];<br>NSDate </em>date = [calendar dateFromComponents:compt];<br>BOOL b = [calendar rangeOfUnit:NSMonthCalendarUnit startDate:&amp;dateOut interval:&amp;count forDate:date];<br>if(b)<br>{<br>    //得到本地时间，避免时区问题<br>    NSTimeZone <em>zone = [NSTimeZone systemTimeZone];<br>    NSInteger interval = [zone secondsFromGMTForDate:dateOut];<br>    NSDate </em>localeDate = [dateOut dateByAddingTimeInterval:interval];</p>
<pre><code>NSLog(@&quot;%@&quot;,localeDate);
NSLog(@&quot;%f&quot;,count);
</code></pre><p>}<br>else<br>{<br>    NSLog(@”无法计算”);<br>}<br>复制代码<br>上面的例子要求返回2013年3月22日当月的起始时间，以及当月的秒数。得到的结果是：2013-03-01 00:00:00 +0000，2678400。(2678400 = 31天 <em> 24小时 </em> 60分 * 60秒)。</p>
<p>假如将上面的日历单位改为NSWeekCalendarUnit，那么得到的结果是：2013-03-17 00:00:00 +0000，604800。当周的第一天是3月17日。(604800 = 7天 <em> 24小时 </em> 60分 * 60秒)。</p>
<p>假如将上面的日历单位改为NSYearCalendarUnit，那么得到的结果是：2013-01-01 00:00:00 +0000，31536000。这一年的第一天是1月1日，(31536000 = 365天 <em> 24小时 </em> 60分 * 60秒)。</p>
<p>NSDateFormatter</p>
<p>NSDateFormatter的日期格式如下:</p>
<p>复制代码<br>G – 纪元<br>一般会显示公元前(BC)和公元(AD)</p>
<p>y – 年<br>假如是2013年，那么yyyy=2013，yy=13  </p>
<p>M – 月<br>假如是3月，那么M=3，MM=03，MMM=Mar，MMMM=March<br>假如是11月，那么M=11，MM=11，MMM=Nov，MMMM=November</p>
<p>w – 年包含的周<br>假如是1月8日，那么w=2(这一年的第二个周)</p>
<p>W – 月份包含的周(与日历排列有关)<br>假如是2013年4月21日，那么W=4(这个月的第四个周)</p>
<p>F – 月份包含的周(与日历排列无关)<br>和上面的W不一样，F只是单纯以7天为一个单位来统计周，例如7号一定是第一个周，15号一定是第三个周，与日历排列无关。</p>
<p>D – 年包含的天数<br>假如是1月20日，那么D=20(这一年的第20天)<br>假如是2月25日，那么D=31+25=56(这一年的第56天)</p>
<p>d – 月份包含的天数<br>假如是5号，那么d=5，dd=05<br>假如是15号，那么d=15，dd=15</p>
<p>E – 星期<br>假如是星期五，那么E=Fri，EEEE=Friday</p>
<p>a – 上午(AM)/下午(PM)</p>
<p>H – 24小时制，显示为0–23<br>假如是午夜00:40，那么H=0:40，HH=00:40</p>
<p>h – 12小时制，显示为1–12<br>假如是午夜00:40，那么h=12:40</p>
<p>K – 12小时制，显示为0–11<br>假如是午夜00:40，那么K=0:40，KK=00:40</p>
<p>k – 24小时制，显示为1–24<br>假如是午夜00:40，那么k=24:40</p>
<p>m – 分钟<br>假如是5分钟，那么m=5，mm=05<br>假如是45分钟，那么m=45，mm=45</p>
<p>s – 秒<br>假如是5秒钟，那么s=5，ss=05<br>假如是45秒钟，那么s=45，ss=45</p>
<p>S – 毫秒<br>一般用SSS来显示</p>
<p>z – 时区<br>表现形式为GMT+08:00</p>
<p>Z – 时区<br>表现形式为+0800<br>复制代码<br>NSDateFormatter的两个最实用的方法是dateFromString和stringFromDate，前者将一个字符串经过格式化后变成NSDate对象，后者将NSDate对象格式化成字符串。</p>
<p>在调用setDateFormat设置格式化字符串时，可以加入一些别的字符串，用单引号来引入，例如：</p>
<p>[formatter setDateFormat:@”yyyy-MM-dd ‘some ‘’special’’ string’ HH:mm:ss”];<br>使用NSDateFormatter转换时间字符串时，默认的时区是系统时区，例如在中国一般都是北京时间(+8)，如果直接转换会导致结果相差8小时，所以一般的做法是先指定时区为GMT标准时间再转换，例如：</p>
<p>复制代码<br>NSDateFormatter *formatter = [[NSDateFormatter alloc] init];<br>[formatter setTimeZone:[NSTimeZone timeZoneForSecondsFromGMT:0]];<br>[formatter setDateFormat:@”yyyy-MM-dd HH:mm:ss z”];</p>
<p>NSDateComponents *compt = [[NSDateComponents alloc] init];<br>[compt setYear:2013];<br>[compt setMonth:3];<br>[compt setDay:13];<br>[compt setHour:1];<br>[compt setMinute:55];<br>[compt setSecond:28];</p>
<p>NSCalendar <em>calendar = [NSCalendar currentCalendar];<br>[calendar setTimeZone:[NSTimeZone timeZoneForSecondsFromGMT:0]];<br>NSDate </em>date = [calendar dateFromComponents:compt];<br>NSLog(@”%@”,date);<br>NSString *str = [formatter stringFromDate:date];<br>NSLog(@”%@”,str);</p>
<h3 id="关于pop-动画引擎两个例子"><a href="#关于pop-动画引擎两个例子" class="headerlink" title="关于pop 动画引擎两个例子"></a>关于pop 动画引擎两个例子</h3><p>取色功能动效遇到两个比较麻烦的点，<br>1). 今天在做一个动画的时候，使用‘pop’时候，发现动作做完了，然后一个按钮使其回归原位，但是再做动作的时候，就只动了一下。难以查看过程，当我打断点到layoutSubviews的时候，果然进去了。然后不知道是谁调用的，于是我去使用time profile看了那一段时间干了什么事。于是看到了layoutSubviews被调用了，是‘pop’某一块调用了，使view又跑回原位。这时候，要么将布局代码写到其他地方，要么使用UIView的动画，我选择了后者。<br>2). 在一个回馈动效中使用POPSpringAnimation，但是由于滑块可以快速多次滑动，所以在弹性高过预定值，会产生negative值，即负值，这时3D transform中，scaleXY会出现rotate情况，<code>https://github.com/facebook/pop/issues/76</code>，这里采用clamp，在结束时，不超过回弹值。可以使用下面给出的两端中其一都可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-(void)popupMensionNode&#123;</span><br><span class="line">    POPBasicAnimation *nodeAnim = [POPBasicAnimation animationWithPropertyNamed:kPOPLayerScaleXY];</span><br><span class="line">    nodeAnim.toValue = [NSValue valueWithCGSize:CGSizeMake(1.f, 1.f)];</span><br><span class="line">    nodeAnim.fromValue = [NSValue valueWithCGSize:CGSizeMake(0.f, 0.f)];</span><br><span class="line">    nodeAnim.autoreverses = YES;</span><br><span class="line">    nodeAnim.duration = 0.25;</span><br><span class="line">    [_textNode.layer pop_addAnimation:nodeAnim forKey:NSStringFromSelector(_cmd)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-(void)popupMensionNode&#123;</span><br><span class="line">    POPSpringAnimation *imageNodeAnim = [POPSpringAnimation animationWithPropertyNamed:kPOPLayerScaleXY];</span><br><span class="line">    imageNodeAnim.toValue = [NSValue valueWithCGSize:CGSizeMake(1.f, 1.f)];</span><br><span class="line">    imageNodeAnim.fromValue = [NSValue valueWithCGSize:CGSizeMake(0.f, 0.f)];</span><br><span class="line">    imageNodeAnim.autoreverses = YES;</span><br><span class="line">    imageNodeAnim.clampMode = kPOPAnimationClampEnd;</span><br><span class="line">    imageNodeAnim.springBounciness = 8;</span><br><span class="line">//    imageNodeAnim.springSpeed = 20;</span><br><span class="line">    [_textNode.layer pop_addAnimation:imageNodeAnim forKey:NSStringFromSelector(_cmd)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="今天遇到这么个问题-UIImageView-上面有控件-label-和button-但是看起来很模糊"><a href="#今天遇到这么个问题-UIImageView-上面有控件-label-和button-但是看起来很模糊" class="headerlink" title="今天遇到这么个问题 UIImageView 上面有控件 label 和button ,但是看起来很模糊"></a>今天遇到这么个问题 UIImageView 上面有控件 label 和button ,但是看起来很模糊</h3><p>今天遇到这么个问题 UIImageView 上面有控件 label 和button ,但是看起来很模糊。我当时以为其是否因为是被设置backgroundColor ,但是在设置了UIImageView的图片时，还是模糊。目前未知原因，leave a tag。</p>
<h3 id="浮点精度计算-http-www-jianshu-com-p-25d24a184016"><a href="#浮点精度计算-http-www-jianshu-com-p-25d24a184016" class="headerlink" title="浮点精度计算  http://www.jianshu.com/p/25d24a184016"></a>浮点精度计算  <a href="http://www.jianshu.com/p/25d24a184016" target="_blank" rel="noopener">http://www.jianshu.com/p/25d24a184016</a></h3><p>NSDecimalNumber <em>price1 = [NSDecimalNumber decimalNumberWithString:@”15.99”];<br>NSDecimalNumber </em>price2 = [NSDecimalNumber decimalNumberWithString:@”29.99”];<br>NSDecimalNumber <em>coupon = [NSDecimalNumber decimalNumberWithString:@”5.00”];<br>NSDecimalNumber </em>discount = [NSDecimalNumber decimalNumberWithString:@”.90”];<br>NSDecimalNumber <em>numProducts = [NSDecimalNumber decimalNumberWithString:@”2.0”];<br>NSDecimalNumber </em>subtotal = [price1 decimalNumberByAdding:price2];//price1+price2<br>NSDecimalNumber <em>afterCoupon = [subtotal decimalNumberBySubtracting:coupon];//subtotal-conpon<br>NSDecimalNumber </em>afterDiscount = [afterCoupon decimalNumberByMultiplyingBy:discount];//afterCoupon<em>discount<br>NSDecimalNumber </em>average = [afterDiscount decimalNumberByDividingBy:numProducts];//afterDiscount/2<br>NSDecimalNumber <em>averageSquared = [average decimalNumberByRaisingToPower:2];//average</em>average<br>NSLog(@”Subtotal: %@”, subtotal);                       // 45.98<br>NSLog(@”After coupon: %@”, afterCoupon);                // 40.98<br>NSLog((@”After discount: %@”), afterDiscount);          // 36.882<br>NSLog(@”Average price per product: %@”, average);       // 18.441<br>NSLog(@”Average price squared: %@”, averageSquared);    // 340.070481</p>
<h3 id="iOS多target-http-www-cnblogs-com-yajunLi-p-6001132-html"><a href="#iOS多target-http-www-cnblogs-com-yajunLi-p-6001132-html" class="headerlink" title="iOS多target http://www.cnblogs.com/yajunLi/p/6001132.html"></a>iOS多target <a href="http://www.cnblogs.com/yajunLi/p/6001132.html" target="_blank" rel="noopener">http://www.cnblogs.com/yajunLi/p/6001132.html</a></h3><p>iOS 如何创建多个target，同时表达多target的意义</p>
<h3 id="理解的营收模式"><a href="#理解的营收模式" class="headerlink" title="理解的营收模式"></a>理解的营收模式</h3><p>1：类似onePassword   可以试用1个月 然后，需要购买服务，，收费，，也不贵，，大概也是6、7、10块这样的，永久使用，，，<br>2：限制一些输入，，比如用户可以选择我们给的默认文案，但是用户要自定义，，那就收费，，再给会员予以多个账本创建能力，，，未付费仅能使用1个<br>3：增值服务收费吧；云同步，导出账本，这一类功能开放<br>4：增值服务和广告</p>
<p>多快好省</p>

  </article>
  <footer class="f-cf">
    
      <a href="/2018/03/04/2018-3-3lesson/" class="link f-fl">⟵2018/3/4Lesson</a>
    
    
      <a href="/2017/08/24/2017-08-24lesson/" class="link f-fr">2017/08/24lesson⟶</a>
    
  </footer>
</section></div>
    <footer id="footer" class="f-cf">
  d.guangying@foxmail.com
  
    
      
        · <a href="https://dribbble.com/clovertuan" target="_blank" class="nav-icn">Dribbble</a>
      
    
      
        · <a href="https://www.behance.net/clovertuan" target="_blank" class="nav-icn">Behance</a>
      
    
      
        · <a href="http://clovertuan.lofter.com/" target="_blank" class="nav-icn">Lofter</a>
      
    
      
        · <a href="https://www.instagram.com/clovertuan/" target="_blank" class="nav-icn">Instagram</a>
      
    
      
        · <a href="https://github.com/cloverTuan" target="_blank" class="nav-icn">GitHub</a>
      
    
  
  <span class="copyright">All rights reserved @Clover Tuan</span>
</footer>
  </div>
</body>
</html>