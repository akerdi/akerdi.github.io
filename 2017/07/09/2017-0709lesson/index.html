<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>2017/0709lesson | aKer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="2017/05/31使用UIEffectView 的一个坑：UIEffectView的实现方式是将底部的着色吸附到当前View中。我喜欢使用帧动画，pop更加爱，于是出现一个情况，该effectView在上下滑动时，吸附的图片会出现在之前的位置，很不稳定，估计是使用局部变量编写，然后没有着色在之前的rect上面，出现有刷新当前区域指令的时候，就会清楚这块不稳定内容。这个问题重点在动画上。pop帧动">
<meta property="og:type" content="article">
<meta property="og:title" content="2017&#x2F;0709lesson">
<meta property="og:url" content="https://akerdi.github.io/2017/07/09/2017-0709lesson/index.html">
<meta property="og:site_name" content="aKer">
<meta property="og:description" content="2017/05/31使用UIEffectView 的一个坑：UIEffectView的实现方式是将底部的着色吸附到当前View中。我喜欢使用帧动画，pop更加爱，于是出现一个情况，该effectView在上下滑动时，吸附的图片会出现在之前的位置，很不稳定，估计是使用局部变量编写，然后没有着色在之前的rect上面，出现有刷新当前区域指令的时候，就会清楚这块不稳定内容。这个问题重点在动画上。pop帧动">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2023-03-07T09:24:38.364Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="2017&#x2F;0709lesson">
<meta name="twitter:description" content="2017/05/31使用UIEffectView 的一个坑：UIEffectView的实现方式是将底部的着色吸附到当前View中。我喜欢使用帧动画，pop更加爱，于是出现一个情况，该effectView在上下滑动时，吸附的图片会出现在之前的位置，很不稳定，估计是使用局部变量编写，然后没有着色在之前的rect上面，出现有刷新当前区域指令的时候，就会清楚这块不稳定内容。这个问题重点在动画上。pop帧动">
  
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
  <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      document.querySelectorAll('pre code').forEach((block) => {
        hljs.highlightBlock(block);
      });
    });
  </script>
  <link rel="stylesheet" href="/css/index.css">
</head>
</html>
<body style="


  background-color: #eff0f6

">
  <div id="container">
    <nav id="nav">
  <header class="header">
    <a href="/" class="title">Clover Tuan</a>
  </header>
  <div class="ctnWrap">
    <div class="icons">
      
        
          
            <a href="https://dribbble.com/clovertuan" target="_blank" class="nav-icn iconfont icon-dribbble"></a>
          
        
          
            <a href="https://www.behance.net/clovertuan" target="_blank" class="nav-icn iconfont icon-behance"></a>
          
        
          
            <a href="http://clovertuan.lofter.com/" target="_blank" class="nav-icn iconfont icon-lofter"></a>
          
        
          
            <a href="https://www.instagram.com/clovertuan/" target="_blank" class="nav-icn iconfont icon-instagram"></a>
          
        
          
            <a href="https://github.com/cloverTuan" target="_blank" class="nav-icn iconfont icon-github"></a>
          
        
      
    </div>
    <div class="menu">
      
        
            <a href="/" class="nav-menu ">HOME</a>
          
        
            <a href="/archives" class="nav-menu ">ARCHIVE</a>
          
        
            <a href="/about" class="nav-menu ">ABOUT</a>
          
        
      
    </div>
  </div>
</nav>
    <div id="main"><section class="article">
  <h2 class="title">2017/0709lesson</h2>
  <p class="sub">Jul 9, 2017</p>
  <article class="content">
    <h3 id="2017-05-31"><a href="#2017-05-31" class="headerlink" title="2017/05/31"></a>2017/05/31</h3><p>使用UIEffectView 的一个坑：UIEffectView的实现方式是将底部的着色吸附到当前View中。我喜欢使用帧动画，pop更加爱，于是出现一个情况，该effectView在上下滑动时，吸附的图片会出现在之前的位置，很不稳定，估计是使用局部变量编写，然后没有着色在之前的rect上面，出现有刷新当前区域指令的时候，就会清楚这块不稳定内容。<br>这个问题重点在动画上。pop帧动画，采用逐步转移，而不是我现在解决使用的UIView动画。UIView动画是点到终点的动画，而pop是过程可逆的过程动画。</p>
<h3 id="这里记录一次ASDK中滑动卡顿一愣一愣，以及push卡顿。"><a href="#这里记录一次ASDK中滑动卡顿一愣一愣，以及push卡顿。" class="headerlink" title="这里记录一次ASDK中滑动卡顿一愣一愣，以及push卡顿。"></a>这里记录一次ASDK中滑动卡顿一愣一愣，以及push卡顿。</h3><p>ASDK滑动卡顿解决过程，使用将其他因素全部关掉方法。心里解决难，是因为其还有其他可能卡顿因素，所以不觉得是因为在ASDK内容物问题，因为试图由好几个层级嵌套合成。真正卡顿在ASCellNode里面，由于设计图要有cornerRadius ，单元格要有shadow，于是我加在didLoad方法里面。但是每次滑动过程，可能走到了shadow 过程，于是试图又尝试算了一遍。<br>push卡顿问题，首先要理解试图从创建过程，到压栈完成的流程。首先走init方法、接着走pushViewcontroller、viewDidLoad方法、然后走push压栈动画、最后viewwillappear。由于压栈动画是要有主线程的，当然viewDidLoad中也是有主线程卡主，那么也会有进入很慢的过程。<br>这次是因为我加了一个小方法-&gt;使用SVGKit 加载一个svg 然后转成image过程。在其中一个UIView的子UIButton使用了该转换的Image，于是我一次次打log，计算时间消耗，该处消耗0.6s，而且是在主线程，于是该处出现了卡顿。</p>
<h3 id="锤子和钉子，工具和需求"><a href="#锤子和钉子，工具和需求" class="headerlink" title="锤子和钉子，工具和需求"></a>锤子和钉子，工具和需求</h3><p>前两天在看数据库Realm，后半段功能。然不尽了解内里，所以想问公司其他人了解我所不了解的需求完成过程。但是和他们说的过程中，博士一句话点醒了我：钉子是先存在的，然后找到了锤子解决；而不是拿着锤子寻找钉子。给我的醒悟是，如果我一开始还没有钉子（后半段功能产生的需求），却急于找到锤子，那么没有钉子的需求，很快我也将忘了锤子；所以我慢了下来：在目前碰到的钉子，使用一个个不同的锤子解决。</p>
<h3 id="记录一次碰到僵尸代码以及解决过程"><a href="#记录一次碰到僵尸代码以及解决过程" class="headerlink" title="记录一次碰到僵尸代码以及解决过程"></a>记录一次碰到僵尸代码以及解决过程</h3><p>当前页面是这样：push到的DetailVC 有navigationDelegate，作为转场代理，DetailVC操作完进入“完成、分享页面”，然后有这一份代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.tabBarController.selectedIndex = 1;</span><br><span class="line">[self.navigationController popToRootViewControllerAnimated:NO];</span><br></pre></td></tr></table></figure></p>
<p>让其转向tabbar为1（之前tabbarindex=0），然后popToRootVC；这里引导出了一个问题，我再点击Tabbar=0时，此时的navigationDelegate还是detailVC，但是却早已经被dealloc了，于是就崩溃。解决是viewwillDisappear处将navigationDelegate置空。<br>OK，代码解决为之上处理，但是一开始碰到这个crash的时候，程序什么提示都没有，直接进入AppDelegate的“Bad Access XXXX”。查阅资料：<a href="http://www.cocoachina.com/bbs/read.php?tid-257873.html" target="_blank" rel="noopener"></a> :你得先知道哪报错，按下面设一下，结合日志，先找到错误的代码,<br>设置NSZombieEnabled、MallocStackLogging、NSAutoreleaseFreedObjectCheckEnabled、NSDebugEnabled：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. Product-&gt;Edit Scheme...-&gt;Run...-&gt;EnvironmentVariables. </span><br><span class="line">2. add NSZombieEnabled，set the value with YES</span><br><span class="line">3. add MallocStackLogging, set the value with YES.</span><br><span class="line">4. add NSAutoreleaseFreedObjectCheckEnabled, set the value with YES.</span><br><span class="line">5. add NSDebugEnabled, set the value with YES.</span><br></pre></td></tr></table></figure></p>
<p>这时程序console才会打出说<code>*** -[XXXXXViewC respondsToSelector:]: message sent to deallocated instance 0x134ed5900</code><br>这时又借鉴这两篇文章:<a href="http://www.cnblogs.com/myblog-12368/p/4367034.html" target="_blank" rel="noopener"></a><br><a href="http://blog.csdn.net/smking/article/details/43775523" target="_blank" rel="noopener"></a><br>后一篇跟我的很类似，都是根据VC 和 delegate 之间的关系。然后得以解决</p>
<h3 id="library-not-found-for-lcrt"><a href="#library-not-found-for-lcrt" class="headerlink" title="library not found for -lcrt"></a>library not found for -lcrt</h3><p>出现这个错误，是因为你的测试版本号太高了，以前Demo的版本低于你能运行的版本，解决：Targets-&gt;General-&gt;Deployment Info-&gt;Deployment Target改为当前Xcode能运行的最低版本</p>
<h3 id="viewModel-xxxCommand-execute-在其返回executionSignals之前调用，不会走executionSignal方法"><a href="#viewModel-xxxCommand-execute-在其返回executionSignals之前调用，不会走executionSignal方法" class="headerlink" title="[viewModel.xxxCommand execute]在其返回executionSignals之前调用，不会走executionSignal方法"></a>[viewModel.xxxCommand execute]在其返回executionSignals之前调用，不会走executionSignal方法</h3><p>今天调试一个网络，由于试试写法execute方法，这次将其写在executionSignals之前，怎么都不会走，我怎么看写法都不可能错，在将挂起方法：execute写到后面才走。在此记录一个，有机会再看是什么缘由。</p>
<h3 id="iOS跳转到具体某个应用的设置"><a href="#iOS跳转到具体某个应用的设置" class="headerlink" title="iOS跳转到具体某个应用的设置"></a>iOS跳转到具体某个应用的设置</h3><p><a href="http://blog.csdn.net/jsjxiaobing/article/details/51260753" target="_blank" rel="noopener">http://blog.csdn.net/jsjxiaobing/article/details/51260753</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">NSString * UIApplicationOpenSettingsURLString = @&quot;prefs:root=WIFI&quot;;  </span><br><span class="line">NSURL * url = [NSURL URLWithString:UIApplicationOpenSettingsURLString];  </span><br><span class="line">if([[UIApplication sharedApplication] canOpenURL:url]) &#123;  </span><br><span class="line">    [[UIApplication sharedApplication] openURL:url];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">About — prefs:root=General&amp;path=About  </span><br><span class="line"> Accessibility — prefs:root=General&amp;path=ACCESSIBILITY  </span><br><span class="line"> AirplaneModeOn— prefs:root=AIRPLANE_MODE  </span><br><span class="line"> Auto-Lock — prefs:root=General&amp;path=AUTOLOCK  </span><br><span class="line"> Brightness — prefs:root=Brightness  </span><br><span class="line"> Bluetooth — prefs:root=General&amp;path=Bluetooth  </span><br><span class="line"> Date&amp; Time — prefs:root=General&amp;path=DATE_AND_TIME  </span><br><span class="line"> FaceTime — prefs:root=FACETIME  </span><br><span class="line"> General— prefs:root=General  </span><br><span class="line"> Keyboard — prefs:root=General&amp;path=Keyboard  </span><br><span class="line"> iCloud — prefs:root=CASTLE  iCloud  </span><br><span class="line"> Storage &amp; Backup — prefs:root=CASTLE&amp;path=STORAGE_AND_BACKUP  </span><br><span class="line"> International — prefs:root=General&amp;path=INTERNATIONAL  </span><br><span class="line"> Location Services — prefs:root=LOCATION_SERVICES  </span><br><span class="line"> Music — prefs:root=MUSIC  </span><br><span class="line"> Music Equalizer — prefs:root=MUSIC&amp;path=EQ  </span><br><span class="line"> Music VolumeLimit— prefs:root=MUSIC&amp;path=VolumeLimit  </span><br><span class="line"> Network — prefs:root=General&amp;path=Network  </span><br><span class="line"> Nike + iPod — prefs:root=NIKE_PLUS_IPOD  </span><br><span class="line"> Notes — prefs:root=NOTES  </span><br><span class="line"> Notification — prefs:root=NOTIFICATIONS_ID  </span><br><span class="line"> Phone — prefs:root=Phone  </span><br><span class="line"> Photos — prefs:root=Photos  </span><br><span class="line"> Profile — prefs:root=General&amp;path=ManagedConfigurationList  </span><br><span class="line"> Reset — prefs:root=General&amp;path=Reset  </span><br><span class="line"> Safari — prefs:root=Safari  Siri — prefs:root=General&amp;path=Assistant  </span><br><span class="line"> Sounds — prefs:root=Sounds  </span><br><span class="line"> SoftwareUpdate— prefs:root=General&amp;path=SOFTWARE_UPDATE_LINK  </span><br><span class="line"> Store — prefs:root=STORE  </span><br><span class="line"> Twitter — prefs:root=TWITTER  </span><br><span class="line"> Usage — prefs:root=General&amp;path=USAGE  </span><br><span class="line"> VPN — prefs:root=General&amp;path=Network/VPN  </span><br><span class="line"> Wallpaper — prefs:root=Wallpaper  </span><br><span class="line"> Wi-Fi — prefs:root=WIFI  </span><br><span class="line"> Setting—prefs:root=INTERNET_TETHERING</span><br></pre></td></tr></table></figure></p>
<h3 id="记一次Instrument-Time-Profile-过程"><a href="#记一次Instrument-Time-Profile-过程" class="headerlink" title="记一次Instrument - Time Profile 过程"></a>记一次Instrument - Time Profile 过程</h3><p>xcode 8.+在使用Time Profile中，会出现信息不完整，没法指示更多有用的信息。<br>首先由这篇文章：<a href="http://www.cnblogs.com/ym123/p/4324335.html能明白大概操作内容。在xcode" target="_blank" rel="noopener">http://www.cnblogs.com/ym123/p/4324335.html能明白大概操作内容。在xcode</a> 8.+中，CallTree被移动到最下方而不是右下角处。然后跟着走的时候，并没有显示文章中说的<code>图标为黑色头像的就是Time Profiler给我们的提示，有可能存在性能瓶颈的地方，可以逐渐向下展开，找到产生的根本原因。</code>这个；<br>我又找了找这篇文章：<a href="http://www.jianshu.com/p/179d69f636b0" target="_blank" rel="noopener">http://www.jianshu.com/p/179d69f636b0</a><br>原来是需要在Target-Build Settings-Debug Information Format-Debug 选择dwarf-with-dsym，如果没有该选项，需要手动打入。<br>同时开启TimeProfile就可以看到黑色头像，同时各个方法调用栈就出来。<br>我的操作是：先点击你需要debug的附近区域，然后CPU Usage会有很多波动，然后你可以暂停（stop，不是shut down）同时选中该波动区域附近，形成一个区间。然后下方的调用栈即为该时间区域的调用信息。即得到所需要信息。</p>
<h3 id="记一次硬磕UI、转场遇到的问题"><a href="#记一次硬磕UI、转场遇到的问题" class="headerlink" title="记一次硬磕UI、转场遇到的问题"></a>记一次硬磕UI、转场遇到的问题</h3><p>1：转场的时候alpha很重要，比如pushTransitino的时候，toVC的alpha一开始就要设好，如果animate组，半途还有转变动画，那么会带来感觉像是掉帧的bug。fromVC也一样，多调试这一块，结合Time Profile看这中间有没有其他重操作，提前做，或者之后做。<br>2：pop的时候，与push很像。这里提一点，动作与控制要同步，比如转场里面某一元素，如果动画场景不一致，会带来断层，中间的东西没了，然后又有了。比如我后退，立马把该元素隐藏，但是等到要做动画其实还要几毫秒，于是就会出现断层。这时候最好的就是先在contextView中添好该元素试图覆盖，然后再隐藏。<br>多用动画稿，尽量不要埋头苦调试，没有数值真的很麻烦。</p>
<h3 id="昨晚看到一个帖子列出好的一些iOS片段，我继续删减，留下适合我，我可能会遇到的"><a href="#昨晚看到一个帖子列出好的一些iOS片段，我继续删减，留下适合我，我可能会遇到的" class="headerlink" title="昨晚看到一个帖子列出好的一些iOS片段，我继续删减，留下适合我，我可能会遇到的"></a>昨晚看到一个帖子列出好的一些iOS片段，我继续删减，留下适合我，我可能会遇到的</h3><h5 id="去除数组中重复的对象"><a href="#去除数组中重复的对象" class="headerlink" title="去除数组中重复的对象"></a>去除数组中重复的对象</h5><p><code>NSArray *newArr = [oldArr valueForKeyPath:@“@distinctUnionOfObjects.self&quot;];</code></p>
<h5 id="动画切换window的根控制器"><a href="#动画切换window的根控制器" class="headerlink" title="动画切换window的根控制器"></a>动画切换window的根控制器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// options是动画选项</span><br><span class="line">[UIView transitionWithView:[UIApplication sharedApplication].keyWindow duration:0.5f options:UIViewAnimationOptionTransitionCrossDissolve animations:^&#123;</span><br><span class="line">        BOOL oldState = [UIView areAnimationsEnabled];</span><br><span class="line">        [UIView setAnimationsEnabled:NO];</span><br><span class="line">        [UIApplication sharedApplication].keyWindow.rootViewController = [RootViewController new];</span><br><span class="line">        [UIView setAnimationsEnabled:oldState];</span><br><span class="line">    &#125; completion:^(BOOL finished) &#123;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<h5 id="由角度转换弧度"><a href="#由角度转换弧度" class="headerlink" title="由角度转换弧度"></a>由角度转换弧度</h5><p>`</p>
<p>#define DegreesToRadian(x) (M_PI * (x) / 180.0)<br>`</p>
<h5 id="控制屏幕旋转，在控制器中写"><a href="#控制屏幕旋转，在控制器中写" class="headerlink" title="控制屏幕旋转，在控制器中写"></a>控制屏幕旋转，在控制器中写</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/** 是否支持自动转屏 */</span><br><span class="line">- (BOOL)shouldAutorotate &#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/** 支持哪些屏幕方向 */</span><br><span class="line">- (UIInterfaceOrientationMask)supportedInterfaceOrientations &#123;</span><br><span class="line">    return UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/** 默认的屏幕方向（当前ViewController必须是通过模态出来的UIViewController（模态带导航的无效）方式展现出来的，才会调用这个方法） */</span><br><span class="line">- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation &#123;</span><br><span class="line">    return UIInterfaceOrientationLandscapeLeft | UIInterfaceOrientationLandscapeRight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="几个常用权限判断"><a href="#几个常用权限判断" class="headerlink" title="几个常用权限判断"></a>几个常用权限判断</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    if ([CLLocationManager authorizationStatus] ==kCLAuthorizationStatusDenied) &#123;</span><br><span class="line">        NSLog(@&quot;没有定位权限&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    AVAuthorizationStatus statusVideo = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo];</span><br><span class="line">    if (statusVideo == AVAuthorizationStatusDenied) &#123;</span><br><span class="line">        NSLog(@&quot;没有摄像头权限&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //是否有麦克风权限</span><br><span class="line">    AVAuthorizationStatus statusAudio = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeAudio];</span><br><span class="line">    if (statusAudio == AVAuthorizationStatusDenied) &#123;</span><br><span class="line">        NSLog(@&quot;没有录音权限&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    [PHPhotoLibrary requestAuthorization:^(PHAuthorizationStatus status) &#123;</span><br><span class="line">        if (status == PHAuthorizationStatusDenied) &#123;</span><br><span class="line">            NSLog(@&quot;没有相册权限&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>
<h5 id="判断图片类型"><a href="#判断图片类型" class="headerlink" title="判断图片类型"></a>判断图片类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//通过图片Data数据第一个字节 来获取图片扩展名</span><br><span class="line">- (NSString *)contentTypeForImageData:(NSData *)data</span><br><span class="line">&#123;</span><br><span class="line">    uint8_t c;</span><br><span class="line">    [data getBytes:&amp;c length:1];</span><br><span class="line">    switch (c)</span><br><span class="line">    &#123;</span><br><span class="line">        case 0xFF:</span><br><span class="line">            return @&quot;jpeg&quot;;</span><br><span class="line"> </span><br><span class="line">        case 0x89:</span><br><span class="line">            return @&quot;png&quot;;</span><br><span class="line"> </span><br><span class="line">        case 0x47:</span><br><span class="line">            return @&quot;gif&quot;;</span><br><span class="line"> </span><br><span class="line">        case 0x49:</span><br><span class="line">        case 0x4D:</span><br><span class="line">            return @&quot;tiff&quot;;</span><br><span class="line"> </span><br><span class="line">        case 0x52:</span><br><span class="line">        if ([data length] &lt; 12) &#123;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding];</span><br><span class="line">        if ([testString hasPrefix:@&quot;RIFF&quot;]</span><br><span class="line">            &amp;&amp; [testString hasSuffix:@&quot;WEBP&quot;])</span><br><span class="line">        &#123;</span><br><span class="line">            return @&quot;webp&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="获取手机和app信息"><a href="#获取手机和app信息" class="headerlink" title="获取手机和app信息"></a>获取手机和app信息</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary];  </span><br><span class="line"> CFShow(infoDictionary);  </span><br><span class="line">// app名称  </span><br><span class="line"> NSString *app_Name = [infoDictionary objectForKey:@&quot;CFBundleDisplayName&quot;];  </span><br><span class="line"> // app版本  </span><br><span class="line"> NSString *app_Version = [infoDictionary objectForKey:@&quot;CFBundleShortVersionString&quot;];  </span><br><span class="line"> // app build版本  </span><br><span class="line"> NSString *app_build = [infoDictionary objectForKey:@&quot;CFBundleVersion&quot;];  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    //手机序列号  </span><br><span class="line">    NSString* identifierNumber = [[UIDevice currentDevice] uniqueIdentifier];  </span><br><span class="line">    NSLog(@&quot;手机序列号: %@&quot;,identifierNumber);  </span><br><span class="line">    //手机别名： 用户定义的名称  </span><br><span class="line">    NSString* userPhoneName = [[UIDevice currentDevice] name];  </span><br><span class="line">    NSLog(@&quot;手机别名: %@&quot;, userPhoneName);  </span><br><span class="line">    //设备名称  </span><br><span class="line">    NSString* deviceName = [[UIDevice currentDevice] systemName];  </span><br><span class="line">    NSLog(@&quot;设备名称: %@&quot;,deviceName );  </span><br><span class="line">    //手机系统版本  </span><br><span class="line">    NSString* phoneVersion = [[UIDevice currentDevice] systemVersion];  </span><br><span class="line">    NSLog(@&quot;手机系统版本: %@&quot;, phoneVersion);  </span><br><span class="line">    //手机型号  </span><br><span class="line">    NSString* phoneModel = [[UIDevice currentDevice] model];  </span><br><span class="line">    NSLog(@&quot;手机型号: %@&quot;,phoneModel );  </span><br><span class="line">    //地方型号  （国际化区域名称）  </span><br><span class="line">    NSString* localPhoneModel = [[UIDevice currentDevice] localizedModel];  </span><br><span class="line">    NSLog(@&quot;国际化区域名称: %@&quot;,localPhoneModel );  </span><br><span class="line"> </span><br><span class="line">    NSDictionary *infoDictionary = [[NSBundle mainBundle] infoDictionary];  </span><br><span class="line">    // 当前应用名称  </span><br><span class="line">    NSString *appCurName = [infoDictionary objectForKey:@&quot;CFBundleDisplayName&quot;];  </span><br><span class="line">    NSLog(@&quot;当前应用名称：%@&quot;,appCurName);  </span><br><span class="line">    // 当前应用软件版本  比如：1.0.1  </span><br><span class="line">    NSString *appCurVersion = [infoDictionary objectForKey:@&quot;CFBundleShortVersionString&quot;];  </span><br><span class="line">    NSLog(@&quot;当前应用软件版本:%@&quot;,appCurVersion);  </span><br><span class="line">    // 当前应用版本号码   int类型  </span><br><span class="line">    NSString *appCurVersionNum = [infoDictionary objectForKey:@&quot;CFBundleVersion&quot;];  </span><br><span class="line">    NSLog(@&quot;当前应用版本号码：%@&quot;,appCurVersionNum);</span><br></pre></td></tr></table></figure>
<h5 id="获取设备mac地址"><a href="#获取设备mac地址" class="headerlink" title="获取设备mac地址"></a>获取设备mac地址</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">+ (NSString *)macAddress &#123;</span><br><span class="line">    int                 mib[6];</span><br><span class="line">    size_t              len;</span><br><span class="line">    char                *buf;</span><br><span class="line">    unsigned char       *ptr;</span><br><span class="line">    struct if_msghdr    *ifm;</span><br><span class="line">    struct sockaddr_dl  *sdl;</span><br><span class="line"> </span><br><span class="line">    mib[0] = CTL_NET;</span><br><span class="line">    mib[1] = AF_ROUTE;</span><br><span class="line">    mib[2] = 0;</span><br><span class="line">    mib[3] = AF_LINK;</span><br><span class="line">    mib[4] = NET_RT_IFLIST;</span><br><span class="line"> </span><br><span class="line">    if((mib[5] = if_nametoindex(&quot;en0&quot;)) == 0) &#123;</span><br><span class="line">        printf(&quot;Error: if_nametoindex error\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if(sysctl(mib, 6, NULL, &amp;len, NULL, 0) &lt; 0) &#123;</span><br><span class="line">        printf(&quot;Error: sysctl, take 1\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if((buf = malloc(len)) == NULL) &#123;</span><br><span class="line">        printf(&quot;Could not allocate memory. Rrror!\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if(sysctl(mib, 6, buf, &amp;len, NULL, 0) &lt; 0) &#123;</span><br><span class="line">        printf(&quot;Error: sysctl, take 2&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ifm = (struct if_msghdr *)buf;</span><br><span class="line">    sdl = (struct sockaddr_dl *)(ifm + 1);</span><br><span class="line">    ptr = (unsigned char *)LLADDR(sdl);</span><br><span class="line">    NSString *outstring = [NSString stringWithFormat:@&quot;X:X:X:X:X:X&quot;,</span><br><span class="line">                           *ptr, *(ptr+1), *(ptr+2), *(ptr+3), *(ptr+4), *(ptr+5)];</span><br><span class="line">    free(buf);</span><br><span class="line"> </span><br><span class="line">    return outstring;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="拿到当前正在显示的控制器，不管是push进去的，还是present进去的都能拿到"><a href="#拿到当前正在显示的控制器，不管是push进去的，还是present进去的都能拿到" class="headerlink" title="拿到当前正在显示的控制器，不管是push进去的，还是present进去的都能拿到"></a>拿到当前正在显示的控制器，不管是push进去的，还是present进去的都能拿到</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (UIViewController *)getVisibleViewControllerFrom:(UIViewController*)vc &#123;</span><br><span class="line">    if ([vc isKindOfClass:[UINavigationController class]]) &#123;</span><br><span class="line">        return [self getVisibleViewControllerFrom:[((UINavigationController*) vc) visibleViewController]];</span><br><span class="line">    &#125;else if ([vc isKindOfClass:[UITabBarController class]])&#123;</span><br><span class="line">        return [self getVisibleViewControllerFrom:[((UITabBarController*) vc) selectedViewController]];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (vc.presentedViewController) &#123;</span><br><span class="line">            return [self getVisibleViewControllerFrom:vc.presentedViewController];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return vc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="AFNetworking监听网络状态"><a href="#AFNetworking监听网络状态" class="headerlink" title="AFNetworking监听网络状态"></a>AFNetworking监听网络状态</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 监听网络状况</span><br><span class="line">    AFNetworkReachabilityManager *mgr = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line">    [mgr setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">        switch (status) &#123;</span><br><span class="line">            case AFNetworkReachabilityStatusUnknown:</span><br><span class="line">                break;</span><br><span class="line">            case AFNetworkReachabilityStatusNotReachable: &#123;</span><br><span class="line">                [SVProgressHUD showInfoWithStatus:@&quot;当前设备无网络&quot;];</span><br><span class="line">            &#125;</span><br><span class="line">                break;</span><br><span class="line">            case AFNetworkReachabilityStatusReachableViaWiFi:</span><br><span class="line">                [SVProgressHUD showInfoWithStatus:@&quot;当前Wi-Fi网络&quot;];</span><br><span class="line">                break;</span><br><span class="line">            case AFNetworkReachabilityStatusReachableViaWWAN:</span><br><span class="line">                [SVProgressHUD showInfoWithStatus:@&quot;当前蜂窝移动网络&quot;];</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [mgr startMonitoring];</span><br></pre></td></tr></table></figure>
<h5 id="判断该图片是否有透明度通道"><a href="#判断该图片是否有透明度通道" class="headerlink" title="判断该图片是否有透明度通道"></a>判断该图片是否有透明度通道</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  - (BOOL)hasAlphaChannel</span><br><span class="line">&#123;</span><br><span class="line">    CGImageAlphaInfo alpha = CGImageGetAlphaInfo(self.CGImage);</span><br><span class="line">    return (alpha == kCGImageAlphaFirst ||</span><br><span class="line">            alpha == kCGImageAlphaLast ||</span><br><span class="line">            alpha == kCGImageAlphaPremultipliedFirst ||</span><br><span class="line">            alpha == kCGImageAlphaPremultipliedLast);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="获得灰度图"><a href="#获得灰度图" class="headerlink" title="获得灰度图"></a>获得灰度图</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ (UIImage*)covertToGrayImageFromImage:(UIImage*)sourceImage</span><br><span class="line">&#123;</span><br><span class="line">    int width = sourceImage.size.width;</span><br><span class="line">    int height = sourceImage.size.height;</span><br><span class="line"> </span><br><span class="line">    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceGray();</span><br><span class="line">    CGContextRef context = CGBitmapContextCreate (nil,width,height,8,0,colorSpace,kCGImageAlphaNone);</span><br><span class="line">    CGColorSpaceRelease(colorSpace);</span><br><span class="line"> </span><br><span class="line">    if (context == NULL) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    CGContextDrawImage(context,CGRectMake(0, 0, width, height), sourceImage.CGImage);</span><br><span class="line">    CGImageRef contextRef = CGBitmapContextCreateImage(context);</span><br><span class="line">    UIImage *grayImage = [UIImage imageWithCGImage:contextRef];</span><br><span class="line">    CGContextRelease(context);</span><br><span class="line">    CGImageRelease(contextRef);</span><br><span class="line"> </span><br><span class="line">    return grayImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="UILabel设置内边距"><a href="#UILabel设置内边距" class="headerlink" title="UILabel设置内边距"></a>UILabel设置内边距</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">子类化UILabel，重写drawTextInRect方法</span><br><span class="line">- (void)drawTextInRect:(CGRect)rect &#123;</span><br><span class="line">    // 边距，上左下右</span><br><span class="line">    UIEdgeInsets insets = &#123;0, 5, 0, 5&#125;;</span><br><span class="line">    [super drawTextInRect:UIEdgeInsetsInsetRect(rect, insets)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="让手机震动一下"><a href="#让手机震动一下" class="headerlink" title="让手机震动一下"></a>让手机震动一下</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">倒入框架</span><br><span class="line">#import</span><br><span class="line">AudioServicesPlayAlertSound(kSystemSoundID_Vibrate);</span><br><span class="line">或者</span><br><span class="line">AudioServicesPlaySystemSound(kSystemSoundID_Vibrate);</span><br></pre></td></tr></table></figure>
<h5 id="摇一摇功能"><a href="#摇一摇功能" class="headerlink" title="摇一摇功能"></a>摇一摇功能</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、打开摇一摇功能</span><br><span class="line">    [UIApplication sharedApplication].applicationSupportsShakeToEdit = YES;</span><br><span class="line">2、让需要摇动的控制器成为第一响应者</span><br><span class="line">[self becomeFirstResponder];</span><br><span class="line">3、实现以下方法</span><br><span class="line"> </span><br><span class="line">// 开始摇动</span><br><span class="line">- (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event</span><br><span class="line">// 取消摇动</span><br><span class="line">- (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event</span><br><span class="line">// 摇动结束</span><br><span class="line">- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event</span><br></pre></td></tr></table></figure>
<h5 id="UITextView中打开或禁用复制，剪切，选择，全选等功能"><a href="#UITextView中打开或禁用复制，剪切，选择，全选等功能" class="headerlink" title="UITextView中打开或禁用复制，剪切，选择，全选等功能"></a>UITextView中打开或禁用复制，剪切，选择，全选等功能</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 继承UITextView重写这个方法</span><br><span class="line">- (BOOL)canPerformAction:(SEL)action withSender:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">// 返回NO为禁用，YES为开启</span><br><span class="line">    // 粘贴</span><br><span class="line">    if (action == @selector(paste:)) return NO;</span><br><span class="line">    // 剪切</span><br><span class="line">    if (action == @selector(cut:)) return NO;</span><br><span class="line">    // 复制</span><br><span class="line">    if (action == @selector(copy:)) return NO;</span><br><span class="line">    // 选择</span><br><span class="line">    if (action == @selector(select:)) return NO;</span><br><span class="line">    // 选中全部</span><br><span class="line">    if (action == @selector(selectAll:)) return NO;</span><br><span class="line">    // 删除</span><br><span class="line">    if (action == @selector(delete:)) return NO;</span><br><span class="line">    // 分享</span><br><span class="line">    if (action == @selector(share)) return NO;</span><br><span class="line">    return [super canPerformAction:action withSender:sender];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="记录一个“POP”引擎动画后调用了superView的layoutSubViews方法"><a href="#记录一个“POP”引擎动画后调用了superView的layoutSubViews方法" class="headerlink" title="记录一个“POP”引擎动画后调用了superView的layoutSubViews方法"></a>记录一个“POP”引擎动画后调用了superView的layoutSubViews方法</h3><p>今天在做一个动画的时候，使用‘pop’时候，发现动作做完了，然后一个按钮使其回归原位，但是再做动作的时候，就只动了一下。难以查看过程，当我打断点到layoutSubviews的时候，果然进去了。然后不知道是谁调用的，于是我去使用time profile看了那一段时间干了什么事。于是看到了layoutSubviews被调用了，是‘pop’某一块调用了，使view又跑回原位。这时候，要么将布局代码写到其他地方，要么使用UIView的动画，我选择了后者。</p>
<h3 id="POPSpringAnimation-‘scaleXY’-会出现rotate-情况"><a href="#POPSpringAnimation-‘scaleXY’-会出现rotate-情况" class="headerlink" title="POPSpringAnimation ‘scaleXY’ 会出现rotate 情况"></a>POPSpringAnimation ‘scaleXY’ 会出现rotate 情况</h3><p>在一个回馈动效中使用POPSpringAnimation，但是由于滑块可以快速多次滑动，所以在弹性高过预定值，会产生negative值，即负值，这时3D transform中，scaleXY会出现rotate情况，<code>https://github.com/facebook/pop/issues/76</code>，这里采用clamp，在结束时，不超过回弹值。可以使用下面给出的两端中其一都可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-(void)popupMensionNode&#123;</span><br><span class="line">    POPBasicAnimation *nodeAnim = [POPBasicAnimation animationWithPropertyNamed:kPOPLayerScaleXY];</span><br><span class="line">    nodeAnim.toValue = [NSValue valueWithCGSize:CGSizeMake(1.f, 1.f)];</span><br><span class="line">    nodeAnim.fromValue = [NSValue valueWithCGSize:CGSizeMake(0.f, 0.f)];</span><br><span class="line">    nodeAnim.autoreverses = YES;</span><br><span class="line">    nodeAnim.duration = 0.25;</span><br><span class="line">    [_textNode.layer pop_addAnimation:nodeAnim forKey:NSStringFromSelector(_cmd)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-(void)popupMensionNode&#123;</span><br><span class="line">    POPSpringAnimation *imageNodeAnim = [POPSpringAnimation animationWithPropertyNamed:kPOPLayerScaleXY];</span><br><span class="line">    imageNodeAnim.toValue = [NSValue valueWithCGSize:CGSizeMake(1.f, 1.f)];</span><br><span class="line">    imageNodeAnim.fromValue = [NSValue valueWithCGSize:CGSizeMake(0.f, 0.f)];</span><br><span class="line">    imageNodeAnim.autoreverses = YES;</span><br><span class="line">    imageNodeAnim.clampMode = kPOPAnimationClampEnd;</span><br><span class="line">    imageNodeAnim.springBounciness = 8;</span><br><span class="line">//    imageNodeAnim.springSpeed = 20;</span><br><span class="line">    [_textNode.layer pop_addAnimation:imageNodeAnim forKey:NSStringFromSelector(_cmd)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面两个带来的效果还是不尽完美，这时可以更进一步，又要同时有Spring动画效果，又要有回弹，那么只能使用自主操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">-(POPSpringAnimation *)popupMensionNode&#123;</span><br><span class="line">    [_popNode.layer pop_removeAllAnimations];</span><br><span class="line">    </span><br><span class="line">    POPSpringAnimation *nodeAnim = self.popNodeAnima;</span><br><span class="line">    nodeAnim.fromValue = [NSValue valueWithCGSize:CGSizeMake(0.f, 0.f)];</span><br><span class="line">    nodeAnim.toValue = [NSValue valueWithCGSize:CGSizeMake(1.f, 1.f)];</span><br><span class="line">//    nodeAnim.autoreverses = YES;</span><br><span class="line">    nodeAnim.springBounciness = 6;</span><br><span class="line">    [_popNode.layer pop_addAnimation:nodeAnim forKey:NSStringFromSelector(_cmd)];</span><br><span class="line">    </span><br><span class="line">    POPBasicAnimation *minScaleXYAnimate = [POPBasicAnimation animationWithPropertyNamed:kPOPLayerScaleXY];</span><br><span class="line">    minScaleXYAnimate.duration = .2;</span><br><span class="line">    minScaleXYAnimate.toValue = [NSValue valueWithCGSize:CGSizeMake(0.f, 0.f)];</span><br><span class="line">    </span><br><span class="line">    [nodeAnim setCompletionBlock:^(POPAnimation *animation,BOOL complete)&#123;</span><br><span class="line">        if (complete) &#123;</span><br><span class="line">            [_popNode.layer pop_addAnimation:minScaleXYAnimate forKey:@&quot;kminScaleAnimate&quot;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    return nodeAnim;</span><br><span class="line">&#125;</span><br><span class="line">-(POPSpringAnimation *)popNodeAnima&#123;</span><br><span class="line">    if (!_popNodeAnima) &#123;</span><br><span class="line">        _popNodeAnima = [POPSpringAnimation animationWithPropertyNamed:kPOPLayerScaleXY];</span><br><span class="line">    &#125;</span><br><span class="line">    return _popNodeAnima;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样子便不会出现negative值，不会发生rotate，同时还保留有spring动画的停顿效果，多次快速点击也能相应，不会出问题。</p>
<h3 id="更换PinRemoteImage已经保存的图片"><a href="#更换PinRemoteImage已经保存的图片" class="headerlink" title="更换PinRemoteImage已经保存的图片"></a>更换PinRemoteImage已经保存的图片</h3><p>这种做法比较少，但是还是会有此需求，比如我现在做的。<br>要更换就要更换两处，memory cache 和disk cache。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PINRemoteImageManager *imageManager = [PINRemoteImageManager sharedImageManager];</span><br><span class="line">[imageManager.cache removeObjectForKeyFromMemory:model.img_url];</span><br><span class="line">NSData *data = UIImagePNGRepresentation(para1.contentImg);</span><br><span class="line">[imageManager.defaultImageCache setObjectInMemory:data forKey:model.img_url withCost:data.length];</span><br><span class="line">[imageManager.cache setObjectOnDisk:data forKey:model.img_url];</span><br></pre></td></tr></table></figure></p>
<p>model.img_url 是其地址，在disk-&gt;library-&gt;cache-&gt;pincache-&gt;com.pinterest.pinremoteImage目录下，记不清其目录地址，大概是这样的。<br>data是我们要保存的图片的NSData 。</p>
<h3 id="记一次Apple-Develop-center-加多个device-id经历"><a href="#记一次Apple-Develop-center-加多个device-id经历" class="headerlink" title="记一次Apple Develop center 加多个device id经历"></a>记一次Apple Develop center 加多个device id经历</h3><p>1：首先先下载上面一段话的特殊字，写着实例文件。<br>2：然后我跟着写了其格式：<br>1）第一行为无效文字，苹果不填写，仅做log实例。<br>2）第二行开始，左边填写”devices id+’tab’+名称(名称全部用英文写，不要有中文符号，不要有空格，不要奇奇怪怪东西)”<br>3：然后上传基本就可以了</p>
<p>如果中间有出问题，尽量分段上传，这样就可以测试时什么个情况了</p>
<h3 id="iOS解决bug几个方法"><a href="#iOS解决bug几个方法" class="headerlink" title="iOS解决bug几个方法"></a>iOS解决bug几个方法</h3><p>1：用代码管理，每天记录。如果有解决不了的bug，看看几天改了什么，站起来思考（不要坐着）有没有关联；<br>2：如果是在一个文件class 内，可以试试将无关联代码去掉，单方面测试要定位的问题；解决了再回退，最好保存一份文件；<br>3：在断点出左下角+号，有个Exceptions BreakPoint…，直接点击添加，然后运行时自动大部分会自动定位到目标代码；<br>4：如果有崩溃现象，会进入到调用栈，IDE的左上角的小页签会跑到第六个，调用栈里边，这里可以看到你最近的几个方法是怎么跳转的，比如你是哪个线程，调用了哪个栈方法，连续调了哪些方法等等，这个方法很能反应问题实质，你还可以点击到相应的方法，同时打出相应的属性，lldb是可用状态；其他线程的lldb，只能看，不能再记录那些线程的方法属性了；<br>5：看性能损耗，主要还是要看Time Profile;同时僵尸代码的崩溃监控；这个记录由上边的Instrument 记录有记录。</p>

  </article>
  <footer class="f-cf">
    
      <a href="/2017/07/30/2017-7-30lesson/" class="link f-fl">⟵2017/7/30lesson</a>
    
    
      <a href="/2017/05/21/2017-05-20travel/" class="link f-fr">2017/05/20travel⟶</a>
    
  </footer>
</section></div>
    <footer id="footer" class="f-cf">
  d.guangying@foxmail.com
  
    
      
        · <a href="https://dribbble.com/clovertuan" target="_blank" class="nav-icn">Dribbble</a>
      
    
      
        · <a href="https://www.behance.net/clovertuan" target="_blank" class="nav-icn">Behance</a>
      
    
      
        · <a href="http://clovertuan.lofter.com/" target="_blank" class="nav-icn">Lofter</a>
      
    
      
        · <a href="https://www.instagram.com/clovertuan/" target="_blank" class="nav-icn">Instagram</a>
      
    
      
        · <a href="https://github.com/cloverTuan" target="_blank" class="nav-icn">GitHub</a>
      
    
  
  <span class="copyright">All rights reserved @Clover Tuan</span>
</footer>
  </div>
</body>
</html>