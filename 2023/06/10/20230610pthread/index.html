<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>20230610pthread | aKer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="pthread在C++开发中，原生的线程库主要有两个，一个是C++11提供的&amp;lt;thread.h&amp;gt;(Mac/Linux)类，另一个是Linux 下的&amp;lt;pthread.h&amp;gt;(Mac/Windows/Linux)。 std::thread 是C++11中的新特性，将多线程程序的编写提升到了语言层面，是的编写的多线程程序的可移植性大大提供。std::thread更加简便易用，而pt">
<meta name="keywords" content="多线程">
<meta property="og:type" content="article">
<meta property="og:title" content="20230610pthread">
<meta property="og:url" content="https://akerdi.github.io/2023/06/10/20230610pthread/index.html">
<meta property="og:site_name" content="aKer">
<meta property="og:description" content="pthread在C++开发中，原生的线程库主要有两个，一个是C++11提供的&amp;lt;thread.h&amp;gt;(Mac/Linux)类，另一个是Linux 下的&amp;lt;pthread.h&amp;gt;(Mac/Windows/Linux)。 std::thread 是C++11中的新特性，将多线程程序的编写提升到了语言层面，是的编写的多线程程序的可移植性大大提供。std::thread更加简便易用，而pt">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2023-06-12T12:48:34.146Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="20230610pthread">
<meta name="twitter:description" content="pthread在C++开发中，原生的线程库主要有两个，一个是C++11提供的&amp;lt;thread.h&amp;gt;(Mac/Linux)类，另一个是Linux 下的&amp;lt;pthread.h&amp;gt;(Mac/Windows/Linux)。 std::thread 是C++11中的新特性，将多线程程序的编写提升到了语言层面，是的编写的多线程程序的可移植性大大提供。std::thread更加简便易用，而pt">
  
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
  <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      document.querySelectorAll('pre code').forEach((block) => {
        hljs.highlightBlock(block);
      });
    });
  </script>
  <link rel="stylesheet" href="/css/index.css">
</head>
</html>
<body style="


  background-color: #eff0f6

">
  <div id="container">
    <nav id="nav">
  <header class="header">
    <a href="/" class="title">Clover Tuan</a>
  </header>
  <div class="ctnWrap">
    <div class="icons">
      
        
          
            <a href="https://dribbble.com/clovertuan" target="_blank" class="nav-icn iconfont icon-dribbble"></a>
          
        
          
            <a href="https://www.behance.net/clovertuan" target="_blank" class="nav-icn iconfont icon-behance"></a>
          
        
          
            <a href="http://clovertuan.lofter.com/" target="_blank" class="nav-icn iconfont icon-lofter"></a>
          
        
          
            <a href="https://www.instagram.com/clovertuan/" target="_blank" class="nav-icn iconfont icon-instagram"></a>
          
        
          
            <a href="https://github.com/cloverTuan" target="_blank" class="nav-icn iconfont icon-github"></a>
          
        
      
    </div>
    <div class="menu">
      
        
            <a href="/" class="nav-menu ">HOME</a>
          
        
            <a href="/archives" class="nav-menu ">ARCHIVE</a>
          
        
            <a href="/about" class="nav-menu ">ABOUT</a>
          
        
      
    </div>
  </div>
</nav>
    <div id="main"><section class="article">
  <h2 class="title">20230610pthread</h2>
  <p class="sub">Jun 10, 2023</p>
  <article class="content">
    <h1 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h1><p>在C++开发中，原生的线程库主要有两个，一个是C++11提供的&lt;thread.h&gt;(Mac/Linux)类，另一个是Linux 下的&lt;pthread.h&gt;(Mac/Windows/Linux)。</p>
<p>std::thread 是C++11中的新特性，将多线程程序的编写提升到了语言层面，是的编写的多线程程序的可移植性大大提供。<code>std::thread更加简便易用，而pthread功能更加强大。</code></p>
<p>std::thread 使用请参考<a href="./20230610thread.md">这篇内容</a>, 下面我们来介绍pthread 的使用。</p>
<h2 id="pthread-的创建和管理"><a href="#pthread-的创建和管理" class="headerlink" title="pthread 的创建和管理"></a>pthread 的创建和管理</h2><p><code>int(*pthread_create)(pthread_t* thread, pthread_attr_t* attr, void*(*start_routine)(void*), void* arg)</code></p>
<p>若创建成功，返回0。</p>
<ul>
<li>thread 是线程标识符</li>
<li>attr 指定线程的属性，可以用NULL表示默认属性</li>
<li>start_routine 指定线程开始运行的函数</li>
<li>arg 是start_routine 所需要的参数，是一个无类型指针</li>
</ul>
<p>结束线程方法:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span>* retval)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="一个简单的多线程实现"><a href="#一个简单的多线程实现" class="headerlink" title="一个简单的多线程实现"></a>一个简单的多线程实现</h2><p>多线程打印:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS 5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Simple_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">PrintHello</span><span class="params">(<span class="keyword">void</span>* obj)</span> </span>&#123;</span><br><span class="line">    usleep(<span class="number">30</span>);</span><br><span class="line">    <span class="keyword">long</span> tid;</span><br><span class="line">    tid = ((Simple_s*)obj)-&gt;i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World! It's me, thread #%ld!\n"</span>, tid);</span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simple_test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    <span class="keyword">long</span> t;</span><br><span class="line">    <span class="keyword">for</span> (t = <span class="number">0</span>; t &lt; NUM_THREADS; t++) &#123;</span><br><span class="line">        Simple_s* s = (Simple_s*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Simple_s));</span><br><span class="line">        s-&gt;i = t;</span><br><span class="line">        rc = pthread_create(&amp;threads[t], <span class="literal">NULL</span>, PrintHello, s);</span><br><span class="line">        <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR: return code from pthread_create() is %d\n"</span>, rc);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"In main thread: created thread %ld\n"</span>, s-&gt;i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"End created pthread\n"</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的结果为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In main thread: created thread 0</span><br><span class="line">In main thread: created thread 1</span><br><span class="line">In main thread: created thread 2</span><br><span class="line">Hello World! It&apos;s me, thread #0!</span><br><span class="line">In main thread: created thread 3</span><br><span class="line">Hello World! It&apos;s me, thread #1!</span><br><span class="line">Hello World! It&apos;s me, thread #3!</span><br><span class="line">In main thread: created thread 4</span><br><span class="line">Hello World! It&apos;s me, thread #2!</span><br><span class="line">End created pthread</span><br><span class="line"></span><br><span class="line">Hello World! It&apos;s me, thread #4!</span><br></pre></td></tr></table></figure>
<p>当前线程调用pthread_exit()来等待其他线程的结束。（如果不适用这个函数的话，可能main()函数结束了也有线程没有执行完毕！）</p>
<h2 id="对象的阻塞-Joining-and-Detaching-Threads"><a href="#对象的阻塞-Joining-and-Detaching-Threads" class="headerlink" title="对象的阻塞(Joining and Detaching Threads)"></a>对象的阻塞(Joining and Detaching Threads)</h2><p>阻塞是线程之间同步的一种方法。</p>
<p><code>int(*pthread_join)(pthread_t threadid, void** value_ptr)</code></p>
<ul>
<li><p>pthread_join 函数会让调用他的线程等待threadid 线程运行结束之后再运行。</p>
</li>
<li><p>value_ptr 存放了其他线程的返回值。</p>
</li>
</ul>
<p>一个可以被join的线程，仅仅可以被别的一个线程join，如果同时有多个线程尝试join同一个线程时，最终结果是未知的。另外，线程不能join自己。</p>
<p>上面提到过，创建一个线程时，要赋予它一定的属性，这其中就包括joinable or detachable 的属性，只有被声明成joinable的线程，可以被其他线程join。</p>
<p>线程问题除了死锁问题之外，另一个是<code>僵尸线程</code>(zombie thread)。他是一种已经退出来的joinable 的线程，但是等待其他线程调用pthread_join 来join他，以收集他的退出信息(exit status)。如果没有其他线程调用pthread_join 来join他的话，他占用的一些系统资源不会被释放，比如堆栈。如果main()函数需要长时间运行，并且创建大量joinable 的线程，就有可能出现堆栈不足的error。</p>
<p>对于那些不需要join的线程，最好利用pthread_detach,这样他运行结束后，资源就会及时自动释放。</p>
<p>总而言之，创建的没一个线程都应该使用pthread_join 或者pthread_detach 其中一个，以防止<code>僵尸线程</code>的出现。</p>
<p>相关函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pthread_detach(threadid)</span><br><span class="line">pthread_attr_setdetachstate(attr, detachstate)</span><br><span class="line">pthread_attr_getdetachstate(attr, detachstate)</span><br></pre></td></tr></table></figure>
<h2 id="显式地设置一个线程为joinable"><a href="#显式地设置一个线程为joinable" class="headerlink" title="显式地设置一个线程为joinable"></a>显式地设置一个线程为joinable</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">BusyWork</span><span class="params">(<span class="keyword">void</span>* t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">long</span> tid;</span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">0.0</span>;</span><br><span class="line">    tid = *(<span class="keyword">long</span>*)t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread %ld starting...\n"</span>, tid);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        result = result + <span class="built_in">sin</span>(i) * <span class="built_in">tan</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Tread %ld done. Result = %e\n"</span>, tid, result);</span><br><span class="line">    pthread_exit(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> thread[NUM_THREADS];</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    <span class="keyword">long</span> t;</span><br><span class="line">    <span class="keyword">void</span>* status;</span><br><span class="line"></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line">    <span class="keyword">for</span> (t = <span class="number">0</span>; t &lt; NUM_THREADS; t++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Main: creating thread %ld\n"</span>, t);</span><br><span class="line">        <span class="keyword">long</span>* i = (<span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">        *i = t;</span><br><span class="line">        rc = pthread_create(&amp;thread[t], &amp;attr, BusyWork, i);</span><br><span class="line">        <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR, return code from pthread_create() is %d\n"</span>, rc);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (t = <span class="number">0</span>; t &lt; NUM_THREADS; t++) &#123;</span><br><span class="line">        rc = pthread_join(thread[t], &amp;status);</span><br><span class="line">        <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR; return code from pthread_join() is %d\n"</span>, rc);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Main: completed join with thread %ld having a status of %ld\n"</span>, t, *(<span class="keyword">long</span>*)status);</span><br><span class="line">        <span class="built_in">free</span>(status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Main: program completed. Exiting.\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Main: creating thread 0</span><br><span class="line">Main: creating thread 1</span><br><span class="line">Thread 0 starting...</span><br><span class="line">Main: creating thread 2</span><br><span class="line">Thread 1 starting...</span><br><span class="line">Main: creating thread 3</span><br><span class="line">Thread 2 starting...</span><br><span class="line">Thread 3 starting...</span><br><span class="line">Main: creating thread 4</span><br><span class="line">Thread 4 starting...</span><br><span class="line">Tread 3 done. Result = -3.153838e+06</span><br><span class="line">Tread 4 done. Result = -3.153838e+06</span><br><span class="line">Tread 0 done. Result = -3.153838e+06</span><br><span class="line">Main: completed join with thread 0 having a status of 0</span><br><span class="line">Tread 1 done. Result = -3.153838e+06</span><br><span class="line">Main: completed join with thread 1 having a status of 1</span><br><span class="line">Tread 2 done. Result = -3.153838e+06</span><br><span class="line">Main: completed join with thread 2 having a status of 2</span><br><span class="line">Main: completed join with thread 3 having a status of 3</span><br><span class="line">Main: completed join with thread 4 having a status of 4</span><br><span class="line">Main: program completed. Exiting.</span><br></pre></td></tr></table></figure>
<h2 id="堆栈管理-Stack-Management"><a href="#堆栈管理-Stack-Management" class="headerlink" title="堆栈管理(Stack Management)"></a>堆栈管理(Stack Management)</h2><p>相关函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pthread_attr_getstacksize (attr, stacksize)</span><br><span class="line">pthread_attr_setstacksize (attr, stacksize)</span><br><span class="line">pthread_attr_getstackaddr (attr, stackaddr)</span><br><span class="line">pthread_attr_setstackaddr (attr, stackaddr)</span><br></pre></td></tr></table></figure>
<p>堆栈管理重要点在于一个进程内存在数量众多的线程，每个线程默认会占有一定的堆栈大小。这时要防止内存溢出问题，通过调整每个线程堆栈大小合理配置。</p>
<h2 id="互斥锁-Mutex"><a href="#互斥锁-Mutex" class="headerlink" title="互斥锁 Mutex"></a>互斥锁 Mutex</h2><p>Mutex 常常被用来保护那些可以被多个线程访问的共享资源，比如可以防止多个线程同时更新同一个数据时出现混乱。</p>
<p>相关函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_init(mutex, attr)</span><br><span class="line">pthread_mutex_destroy(<span class="keyword">pthread_mutex_t</span>* mutex)</span><br><span class="line">pthread_mutexattr_init(attr)</span><br><span class="line">pthread_mutexattr_destroy(attr)</span><br><span class="line">pthread_mutex_lock(<span class="keyword">pthread_mutex_t</span>* mutex)</span><br><span class="line">pthread_mutex_trylock(<span class="keyword">pthread_mutex_t</span>* mutex)</span><br><span class="line">pthread_mutex_unlock(<span class="keyword">pthread_mutex_t</span>* mutex)</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面是一个利用多线程进行向量点乘的程序，其中需要对dotstr.sum 这个共同读写的数据进行保护:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span>* a;</span><br><span class="line">    <span class="keyword">double</span>* b;</span><br><span class="line">    <span class="keyword">double</span> sum;</span><br><span class="line">    <span class="keyword">int</span> veclen;</span><br><span class="line">&#125; DOTDATA;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMTHRDS 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VECLEN 100000</span></span><br><span class="line">DOTDATA  dotstr;</span><br><span class="line"><span class="keyword">pthread_t</span> callThd[NUMTHRDS];</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutexsum;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">dotprod</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, start, end, len;</span><br><span class="line">    <span class="keyword">long</span> offset;</span><br><span class="line">    <span class="keyword">double</span> mysum, *x, *y;</span><br><span class="line">    offset = (<span class="keyword">long</span>)arg;</span><br><span class="line"></span><br><span class="line">    len = dotstr.veclen;</span><br><span class="line">    start = offset * len;</span><br><span class="line">    end = start + len;</span><br><span class="line">    x = dotstr.a;</span><br><span class="line">    y = dotstr.b;</span><br><span class="line"></span><br><span class="line">    mysum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt; end; i++) &#123;</span><br><span class="line">        mysum += (x[i] * y[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_lock(&amp;mutexsum);</span><br><span class="line">    dotstr.sum += mysum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Thread %ld did %d to %d: mysum=%f global sum=%f\n"</span>, offset, start, end, mysum, dotstr.sum);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutexsum);</span><br><span class="line">    pthread_exit((<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mutex_test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> i;</span><br><span class="line">    <span class="keyword">double</span> *a, *b;</span><br><span class="line">    <span class="keyword">void</span>* status;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"></span><br><span class="line">    a = (<span class="keyword">double</span>*)<span class="built_in">malloc</span>(NUMTHRDS * VECLEN * <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">    b = (<span class="keyword">double</span>*)<span class="built_in">malloc</span>(NUMTHRDS * VECLEN * <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; VECLEN * NUMTHRDS; i++) &#123;</span><br><span class="line">        a[i] = <span class="number">1</span>;</span><br><span class="line">        b[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    dotstr.veclen = VECLEN;</span><br><span class="line">    dotstr.a = a;</span><br><span class="line">    dotstr.b = b;</span><br><span class="line">    dotstr.sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutexsum, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUMTHRDS; i++) &#123;</span><br><span class="line">        pthread_create(&amp;callThd[i], &amp;attr, dotprod, (<span class="keyword">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUMTHRDS; i++) &#123;</span><br><span class="line">        pthread_join(callThd[i], &amp;status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Sum = %f \n"</span>, dotstr.sum);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutexsum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread 3 did 300000 to 400000: mysum=100000.000000 global sum=100000.000000</span><br><span class="line">Thread 1 did 100000 to 200000: mysum=100000.000000 global sum=200000.000000</span><br><span class="line">Thread 0 did 0 to 100000: mysum=100000.000000 global sum=300000.000000</span><br><span class="line">Thread 2 did 200000 to 300000: mysum=100000.000000 global sum=400000.000000</span><br><span class="line">Sum = 400000.000000</span><br></pre></td></tr></table></figure>
<h2 id="条件变量Condition-Variable"><a href="#条件变量Condition-Variable" class="headerlink" title="条件变量Condition Variable"></a>条件变量Condition Variable</h2><p>互斥锁只有两种状态，这限制了他的用途，条件变量允许线程在阻塞的时候等待另一个线程发送的信号，当收到信号，阻塞的线程就被唤醒并试图锁定预支相关的互斥锁，条件变量要和互斥锁结合使用。</p>
<p>相关函数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_wait(condition, mutex)</span><br><span class="line">pthread_cond_signal(condition)</span><br><span class="line">pthread_cond_broadcast(condition)</span><br></pre></td></tr></table></figure>
<p>pthread_cond_wait() 会阻塞调用他的线程，直到收到某一信号。这个函数需要再mutex已经被锁之后进行调用，并且当线程被阻塞时，会自动解锁mutex。信号收到后，线程被唤醒，这时mutex又会被这个线程锁定。</p>
<p>pthread_cond_signal() 函数结束时，必须解锁mutex，以供pthread_cond_wait() 锁定mutex。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>下面是一个例子，三个线程共同访问count 变量，thread2 和thread3 竞争地对其进行加1的操作，thread1等count 达到12的时候，一次性加125. 然后thread2 和thread3再去竞争count 的控制权，直到完成自己的对count加10次的任务。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCOUNT 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COUNT_LIMIT 12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> count_mutex;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> count_threshold_cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">inc_count</span><span class="params">(<span class="keyword">void</span>* t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">long</span> my_id = (<span class="keyword">long</span>)t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TCOUNT; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;count_mutex);</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count == COUNT_LIMIT) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"inc_count(): thread %ld, count = %d Threshold reached."</span>, my_id, count);</span><br><span class="line">            pthread_cond_signal(&amp;count_threshold_cv);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Just sent signal.\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"inc_count(): thread %ld, count = %d, unlocking mutex\n"</span>, my_id, count);</span><br><span class="line">        pthread_mutex_unlock(&amp;count_mutex);</span><br><span class="line"></span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">watch_count</span><span class="params">(<span class="keyword">void</span>* t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> my_id = (<span class="keyword">long</span>)t;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Starting watch_cont(): thread %ld\n"</span>, my_id);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;count_mutex);</span><br><span class="line">    <span class="keyword">while</span> (count &lt; COUNT_LIMIT) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"watch_count(): thread %ld Count= %d. Going into wait...\n"</span>, my_id, count);</span><br><span class="line">        pthread_cond_wait(&amp;count_threshold_cv, &amp;count_mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"watch_count(): thread %ld Condition signal received. Count= %d\n"</span>, my_id,</span><br><span class="line">               count);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"watch_count(): thread %ld Updating the value of count...\n"</span>, my_id, count);</span><br><span class="line">        count += <span class="number">125</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"watch_count(): thread %ld count now = %d.\n"</span>, my_id, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"watch_count(): thread %ld Unlocking mutex.\n"</span>, my_id);</span><br><span class="line">    pthread_mutex_unlock(&amp;count_mutex);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">long</span> t1 = <span class="number">1</span>, t2 = <span class="number">2</span>, t3 = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> threads[NUM_THREADS];</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;count_mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;count_threshold_cv, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line">    pthread_create(&amp;threads[<span class="number">0</span>], &amp;attr, watch_count, (<span class="keyword">void</span>*)t1);</span><br><span class="line">    pthread_create(&amp;threads[<span class="number">1</span>], &amp;attr, inc_count, (<span class="keyword">void</span>*)t2);</span><br><span class="line">    pthread_create(&amp;threads[<span class="number">2</span>], &amp;attr, inc_count, (<span class="keyword">void</span>*)t3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUM_THREADS; i++) &#123;</span><br><span class="line">        pthread_join(threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Main(): Waited and joined with %d threads. Final value of count = %d. Done."</span></span><br><span class="line">           <span class="string">"n"</span>, NUM_THREADS, count);</span><br><span class="line"></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line">    pthread_mutex_destroy(&amp;count_mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;count_threshold_cv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Starting watch_cont(): thread 1</span><br><span class="line">inc_count(): thread 2, count = 1, unlocking mutex</span><br><span class="line">inc_count(): thread 3, count = 2, unlocking mutex</span><br><span class="line">watch_count(): thread 1 Count= 2. Going into wait...</span><br><span class="line">inc_count(): thread 2, count = 3, unlocking mutex</span><br><span class="line">inc_count(): thread 3, count = 4, unlocking mutex</span><br><span class="line">inc_count(): thread 2, count = 5, unlocking mutex</span><br><span class="line">inc_count(): thread 3, count = 6, unlocking mutex</span><br><span class="line">inc_count(): thread 2, count = 7, unlocking mutex</span><br><span class="line">inc_count(): thread 3, count = 8, unlocking mutex</span><br><span class="line">inc_count(): thread 2, count = 9, unlocking mutex</span><br><span class="line">inc_count(): thread 3, count = 10, unlocking mutex</span><br><span class="line">inc_count(): thread 2, count = 11, unlocking mutex</span><br><span class="line">inc_count(): thread 3, count = 12 Threshold reached.Just sent signal.</span><br><span class="line">inc_count(): thread 3, count = 12, unlocking mutex</span><br><span class="line">watch_count(): thread 1 Condition signal received. Count= 12</span><br><span class="line">watch_count(): thread 1 Updating the value of count...</span><br><span class="line">watch_count(): thread 1 count now = 137.</span><br><span class="line">watch_count(): thread 1 Unlocking mutex.</span><br><span class="line">inc_count(): thread 2, count = 138, unlocking mutex</span><br><span class="line">inc_count(): thread 3, count = 139, unlocking mutex</span><br><span class="line">inc_count(): thread 2, count = 140, unlocking mutex</span><br><span class="line">inc_count(): thread 3, count = 141, unlocking mutex</span><br><span class="line">inc_count(): thread 2, count = 142, unlocking mutex</span><br><span class="line">inc_count(): thread 3, count = 143, unlocking mutex</span><br><span class="line">inc_count(): thread 2, count = 144, unlocking mutex</span><br><span class="line">inc_count(): thread 3, count = 145, unlocking mutex</span><br><span class="line">Main(): Waited and joined with 3 threads. Final value of count = 145. Done.</span><br></pre></td></tr></table></figure>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://immortalqx.github.io/2021/12/05/cpp-notes-4/" target="_blank" rel="noopener">pthread</a></p>

  </article>
  <footer class="f-cf">
    
      <a href="/2023/06/10/20230610semaphore/" class="link f-fl">⟵20230610semaphore</a>
    
    
      <a href="/2023/06/10/20230610thread/" class="link f-fr">20230610thread⟶</a>
    
  </footer>
</section></div>
    <footer id="footer" class="f-cf">
  d.guangying@foxmail.com
  
    
      
        · <a href="https://dribbble.com/clovertuan" target="_blank" class="nav-icn">Dribbble</a>
      
    
      
        · <a href="https://www.behance.net/clovertuan" target="_blank" class="nav-icn">Behance</a>
      
    
      
        · <a href="http://clovertuan.lofter.com/" target="_blank" class="nav-icn">Lofter</a>
      
    
      
        · <a href="https://www.instagram.com/clovertuan/" target="_blank" class="nav-icn">Instagram</a>
      
    
      
        · <a href="https://github.com/cloverTuan" target="_blank" class="nav-icn">GitHub</a>
      
    
  
  <span class="copyright">All rights reserved @Clover Tuan</span>
</footer>
  </div>
</body>
</html>